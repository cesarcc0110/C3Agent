{"issue": "14", "test": "#include <iostream>#include <vector>#include <cassert>// Estructura base (debes adaptar si la definición original cambia)struct ListNode {    int val;    ListNode* next;    ListNode(int x) : val(x), next(nullptr) {}};// Declaración de la función implementada en el archivo modificadoListNode* reverseList(ListNode* head);// Función auxiliar para crear una lista desde un vectorListNode* createList(const std::vector<int>& values) {    ListNode dummy(0);    ListNode* current = &dummy;    for (int val : values) {        current->next = new ListNode(val);        current = current->next;    }    return dummy.next;}// Función auxiliar para convertir lista a vectorstd::vector<int> listToVector(ListNode* head) {    std::vector<int> result;    while (head) {        result.push_back(head->val);        head = head->next;    }    return result;}// Test unitariovoid runTest() {    ListNode* input = createList({1, 2, 3, 4, 5});    ListNode* reversed = reverseList(input);    std::vector<int> result = listToVector(reversed);    std::vector<int> expected = {5, 4, 3, 2, 1};    assert(result == expected);    std::cout << 'Test passed!' << std::endl;}int main() {    runTest();    return 0;}"}
{"issue": "15", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    // Create an instance of the class containing the method to be tested\n    // Assuming CheckPerfectNumber is in the same package or imported correctly\n    private final CheckPerfectNumber solution = new CheckPerfectNumber();\n\n    @Test\n    void testPerfectNumberCorrectlyIdentified() {\n        // Known perfect numbers: 6, 28, 496, 8128\n        // With the bug, 28 will return false\n        // The test expects true if the bug is fixed, false if not fixed.\n        // For this test, we expect the *buggy* behavior unless otherwise specified.\n        // A perfect number is a positive integer that is equal to the sum of its proper positive divisors (excluding the number itself).\n\n        // Test a number that should be perfect (but will fail with the bug)\n        // Divisors of 28 are 1, 2, 4, 7, 14. Sum = 1+2+4+7+14 = 28.\n        // With the bug, 14 is missed. Sum = 1+2+4+7 = 14. So it will return false.\n        assertFalse(solution.checkPerfectNumber(28), \"28 should be identified as perfect after fix, but false with bug\");\n\n        // 6: Divisors 1, 2, 3. Sum = 1+2+3 = 6. num/2 is 3. Loop goes up to i < 3 (i.e., i=2). It checks 2. Then misses 3. Bug will affect this.\n        // Oh, wait, the loop is i < num/2. For 6, num/2 is 3. i will be 2. So 3 is missed.\n        // Correct sum for 6: 1 (initial) + 2 + 3 = 6. Buggy sum for 6: 1 (initial) + 2 = 3.\n        assertFalse(solution.checkPerfectNumber(6), \"6 should be perfect after fix, but false with bug\");\n\n        // 496: Divisors 1, 2, 4, 8, 16, 31, 62, 124, 248. Sum = 496.\n        // num/2 is 248. Bug will miss 248.\n        assertFalse(solution.checkPerfectNumber(496), \"496 should be perfect after fix, but false with bug\");\n\n    }\n\n    @Test\n    void testNonPerfectNumbers() {\n        // Numbers that are not perfect, regardless of the bug\n        assertTrue(solution.checkPerfectNumber(1) == false, \"1 is not a perfect number\");\n        assertTrue(solution.checkPerfectNumber(2) == false, \"2 is not a perfect number\"); // Sum=1\n        assertTrue(solution.checkPerfectNumber(4) == false, \"4 is not a perfect number\"); // Sum=1+2=3\n        assertTrue(solution.checkPerfectNumber(7) == false, \"7 is not a perfect number\"); // Sum=1\n        assertTrue(solution.checkPerfectNumber(10) == false, \"10 is not a perfect number\"); // Sum=1+2+5=8\n        assertTrue(solution.checkPerfectNumber(15) == false, \"15 is not a perfect number\"); // Sum=1+3+5=9\n        assertTrue(solution.checkPerfectNumber(30) == false, \"30 is not a perfect number\"); // Sum=1+2+3+5+6+10+15=42\n    }\n\n    @Test\n    void testEdgeCases() {\n        // Negative numbers\n        assertFalse(solution.checkPerfectNumber(-5), \"Negative numbers are not perfect\");\n        assertFalse(solution.checkPerfectNumber(0), \"Zero is not a perfect number\");\n\n        // Prime numbers (only divisor is 1, so sum is always 1)\n        assertFalse(solution.checkPerfectNumber(3), \"Prime number 3 is not perfect\");\n        assertFalse(solution.checkPerfectNumber(5), \"Prime number 5 is not perfect\");\n        assertFalse(solution.checkPerfectNumber(11), \"Prime number 11 is not perfect\");\n    }\n}"}
{"issue": "16", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    private final CountPrimes solution = new CountPrimes();\n\n    @Test\n    void testCountPrimesWithBug() {\n        // These tests expect the *buggy* behavior (count - 1)\n        // A fixed solution would make these assertions fail.\n\n        // Primes less than 10 are 2, 3, 5, 7 (count = 4)\n        // Buggy output: 4 - 1 = 3\n        assertEquals(3, solution.countPrimes(10), \"Expected 3 for n=10 due to bug\");\n\n        // Primes less than 0, 1, 2 should be 0\n        // For n=0, 1, 2, the array size is 0 or 1 or 2. Loop for i=2 won't run.\n        // isPrime will be all false (except potential index 0/1 if array size allows).\n        // count will be 0. Buggy output: 0 - 1 = -1\n        assertEquals(-1, solution.countPrimes(0), \"Expected -1 for n=0 due to bug\");\n        assertEquals(-1, solution.countPrimes(1), \"Expected -1 for n=1 due to bug\");\n        assertEquals(-1, solution.countPrimes(2), \"Expected -1 for n=2 due to bug\"); // isPrime[2] = true; then loop for j won't run. count=1. Buggy: 0.\n\n        // Primes less than 3 are 2 (count = 1)\n        // Buggy output: 1 - 1 = 0\n        assertEquals(0, solution.countPrimes(3), \"Expected 0 for n=3 due to bug\");\n\n        // Primes less than 5 are 2, 3 (count = 2)\n        // Buggy output: 2 - 1 = 1\n        assertEquals(1, solution.countPrimes(5), \"Expected 1 for n=5 due to bug\");\n\n        // Primes less than 20: 2, 3, 5, 7, 11, 13, 17, 19 (count = 8)\n        // Buggy output: 8 - 1 = 7\n        assertEquals(7, solution.countPrimes(20), \"Expected 7 for n=20 due to bug\");\n    }\n\n    @Test\n    void testCountPrimesAfterFix() {\n        // These tests are designed to check the *correct* behavior, assuming the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // Primes less than 10 are 2, 3, 5, 7 (count = 4)\n        assertEquals(4, solution.countPrimes(10), \"Expected 4 for n=10 after fix\");\n\n        // Primes less than 0, 1, 2 should be 0\n        assertEquals(0, solution.countPrimes(0), \"Expected 0 for n=0 after fix\");\n        assertEquals(0, solution.countPrimes(1), \"Expected 0 for n=1 after fix\");\n        assertEquals(0, solution.countPrimes(2), \"Expected 0 for n=2 after fix\");\n\n        // Primes less than 3 are 2 (count = 1)\n        assertEquals(1, solution.countPrimes(3), \"Expected 1 for n=3 after fix\");\n\n        // Primes less than 5 are 2, 3 (count = 2)\n        assertEquals(2, solution.countPrimes(5), \"Expected 2 for n=5 after fix\");\n\n        // Primes less than 20: 2, 3, 5, 7, 11, 13, 17, 19 (count = 8)\n        assertEquals(8, solution.countPrimes(20), \"Expected 8 for n=20 after fix\");\n\n        // Primes less than 100: 2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97 (25 primes)\n        assertEquals(25, solution.countPrimes(100), \"Expected 25 for n=100 after fix\");\n    }\n\n    @Test\n    void testLargeNumberPerformance() {\n        // Test with a larger number to ensure reasonable performance\n        // (The Sieve is efficient, so this shouldn't timeout)\n        long startTime = System.nanoTime();\n        int primesCount = solution.countPrimes(100000); // There are 9592 primes less than 100,000\n        long endTime = System.nanoTime();\n        long duration = (endTime - startTime) / 1_000_000; // milliseconds\n        System.out.println(\"Time taken for n=100000: \" + duration + \"ms\");\n        assertEquals(9592, primesCount, \"Expected 9592 primes less than 100000 after fix\");\n\n        // Test with a slightly larger number\n        startTime = System.nanoTime();\n        primesCount = solution.countPrimes(500000); // There are 41538 primes less than 500,000\n        endTime = System.nanoTime();\n        duration = (endTime - startTime) / 1_000_000; // milliseconds\n        System.out.println(\"Time taken for n=500000: \" + duration + \"ms\");\n        assertEquals(41538, primesCount, \"Expected 41538 primes less than 500000 after fix\");\n    }\n}"}
{"issue": "17", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    private final FindPeakElement solution = new FindPeakElement();\n\n    @Test\n    void testPeakInMiddle() {\n        // These cases should pass even with the bug, as the peak is not at the edges.\n        assertEquals(2, solution.findPeakElement(new int[]{1, 2, 3, 1}), \"Peak at index 2\");\n        assertEquals(1, solution.findPeakElement(new int[]{1, 3, 2, 0}), \"Peak at index 1\");\n        assertEquals(3, solution.findPeakElement(new int[]{1, 2, 0, 5, 4}), \"Peak at index 3\");\n    }\n\n    @Test\n    void testPeakAtEdgesWithBug() {\n        // These tests specifically target the bug: the peak is at index 0 or length - 1.\n        // With the bug, the function will return -1 for these cases.\n\n        // Peak at index 0\n        assertEquals(-1, solution.findPeakElement(new int[]{3, 2, 1}), \"Expected -1 for peak at index 0 due to bug\");\n        assertEquals(-1, solution.findPeakElement(new int[]{10, 5, 2}), \"Expected -1 for peak at index 0 due to bug\");\n\n        // Peak at last index\n        assertEquals(-1, solution.findPeakElement(new int[]{1, 2, 3}), \"Expected -1 for peak at last index due to bug\");\n        assertEquals(-1, solution.findPeakElement(new int[]{5, 10, 15}), \"Expected -1 for peak at last index due to bug\");\n    }\n\n    @Test\n    void testPeakAtEdgesAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // Peak at index 0\n        assertEquals(0, solution.findPeakElement(new int[]{3, 2, 1}), \"Expected 0 for peak at index 0 after fix\");\n        assertEquals(0, solution.findPeakElement(new int[]{10, 5, 2}), \"Expected 0 for peak at index 0 after fix\");\n\n        // Peak at last index\n        assertEquals(2, solution.findPeakElement(new int[]{1, 2, 3}), \"Expected 2 for peak at last index after fix\");\n        assertEquals(2, solution.findPeakElement(new int[]{5, 10, 15}), \"Expected 2 for peak at last index after fix\");\n    }\n\n    @Test\n    void testSingleElementArray() {\n        // A single element array always has a peak at index 0 by definition.\n        assertEquals(0, solution.findPeakElement(new int[]{1}), \"Single element array should have peak at index 0\");\n    }\n\n    @Test\n    void testTwoElementArray() {\n        // For two elements, the peak is the larger one.\n        assertEquals(0, solution.findPeakElement(new int[]{2, 1}), \"Two elements, peak at index 0\");\n        assertEquals(1, solution.findPeakElement(new int[]{1, 2}), \"Two elements, peak at index 1\");\n    }\n\n    @Test\n    void testNoPeakMonotonic() {\n        // Monotonically increasing or decreasing arrays may not have a peak if edges are not considered.\n        // With the bug, these will return -1. A fixed solution should return the edge peak.\n        // For these specific test methods, we expect the fixed behavior to fail the 'WithBug' and pass 'AfterFix'.\n\n        // Test with bug (will return -1)\n        assertEquals(-1, solution.findPeakElement(new int[]{1, 2, 3, 4}), \"Expected -1 for increasing array with bug\");\n        assertEquals(-1, solution.findPeakElement(new int[]{4, 3, 2, 1}), \"Expected -1 for decreasing array with bug\");\n    }\n\n    @Test\n    void testNoPeakConstant() {\n        // Array with all same elements\n        assertEquals(-1, solution.findPeakElement(new int[]{5, 5, 5}), \"No peak in constant array\");\n        assertEquals(-1, solution.findPeakElement(new int[]{1, 1, 1, 1}), \"No peak in constant array\");\n    }\n\n    @Test\n    void testEmptyArray() {\n        // Empty array should return -1 or throw exception (assuming -1 for now)\n        assertEquals(-1, solution.findPeakElement(new int[]{}), \"Empty array should return -1\");\n    }\n}"}
{"issue": "18", "test": "import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    // The solution class itself contains the static 'guess' method and 'picked' variable.\n    // We'll modify 'picked' directly for each test case.\n    private GuessNumber solution;\n\n    @BeforeEach\n    void setUp() {\n        solution = new GuessNumber(); // Re-initialize or just ensure an instance exists\n    }\n\n    @Test\n    void testGuessNumberWithBug() {\n        // These tests expect the *buggy* behavior (return left + 1) when the loop condition 'left < right' breaks\n        // The primary bug is that `g == 0` is never hit due to the loop condition `left < right` which becomes `left == right`\n        // The loop should terminate when left == right, and that 'left' is the answer.\n\n        // picked = 6, n = 10\n        // With the bug, picked=6, n=10 will result in left=6, right=6, then loop terminates and returns 6+1=7\n        GuessNumber.picked = 6;\n        assertEquals(7, solution.guessNumber(10), \"Expected 7 for picked=6, n=10 due to bug\");\n\n        // picked = 1, n = 1\n        // left=1, right=1. Loop condition (left < right) is false. Returns 1+1=2.\n        GuessNumber.picked = 1;\n        assertEquals(2, solution.guessNumber(1), \"Expected 2 for picked=1, n=1 due to bug\");\n\n        // picked = 1, n = 2\n        // Initial: left=1, right=2\n        // mid = 1 + (2-1)/2 = 1\n        // guess(1) -> 0. Returns 1. (This case might pass by chance if picked is the first guess)\n        GuessNumber.picked = 1;\n        assertEquals(1, solution.guessNumber(2), \"Expected 1 for picked=1, n=2 (passes by chance)\");\n\n        // picked = 2, n = 2\n        // Initial: left=1, right=2\n        // mid = 1\n        // guess(1) -> -1 (1 < 2), right = 0. Loop terminates. Returns 1+1=2. (Incorrect)\n        GuessNumber.picked = 2;\n        assertEquals(2, solution.guessNumber(2), \"Expected 2 for picked=2, n=2 (passes by chance if right becomes invalid)\");\n\n        // picked = 5, n = 5\n        // left=1, right=5 -> mid=3, g=-1, right=2 -> left=1, right=2 -> mid=1, g=-1, right=0. Loop terminates. Returns 1+1=2. (Incorrect)\n        GuessNumber.picked = 5;\n        assertEquals(2, solution.guessNumber(5), \"Expected 2 for picked=5, n=5 due to bug\");\n\n        // picked = 1, n = 10 (smallest possible picked value)\n        GuessNumber.picked = 1;\n        assertEquals(2, solution.guessNumber(10), \"Expected 2 for picked=1, n=10 due to bug\");\n\n        // picked = 10, n = 10 (largest possible picked value)\n        GuessNumber.picked = 10;\n        assertEquals(11, solution.guessNumber(10), \"Expected 11 for picked=10, n=10 due to bug\");\n\n    }\n\n    @Test\n    void testGuessNumberAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // picked = 6, n = 10\n        GuessNumber.picked = 6;\n        assertEquals(6, solution.guessNumber(10), \"Expected 6 for picked=6, n=10 after fix\");\n\n        // picked = 1, n = 1\n        GuessNumber.picked = 1;\n        assertEquals(1, solution.guessNumber(1), \"Expected 1 for picked=1, n=1 after fix\");\n\n        // picked = 1, n = 2\n        GuessNumber.picked = 1;\n        assertEquals(1, solution.guessNumber(2), \"Expected 1 for picked=1, n=2 after fix\");\n\n        // picked = 2, n = 2\n        GuessNumber.picked = 2;\n        assertEquals(2, solution.guessNumber(2), \"Expected 2 for picked=2, n=2 after fix\");\n\n        // picked = 5, n = 5\n        GuessNumber.picked = 5;\n        assertEquals(5, solution.guessNumber(5), \"Expected 5 for picked=5, n=5 after fix\");\n\n        // picked = 1, n = 10\n        GuessNumber.picked = 1;\n        assertEquals(1, solution.guessNumber(10), \"Expected 1 for picked=1, n=10 after fix\");\n\n        // picked = 10, n = 10\n        GuessNumber.picked = 10;\n        assertEquals(10, solution.guessNumber(10), \"Expected 10 for picked=10, n=10 after fix\");\n\n        // picked = 7, n = 100 (larger range)\n        GuessNumber.picked = 7;\n        assertEquals(7, solution.guessNumber(100), \"Expected 7 for picked=7, n=100 after fix\");\n\n        // picked = 99, n = 100 (larger range, near max)\n        GuessNumber.picked = 99;\n        assertEquals(99, solution.guessNumber(100), \"Expected 99 for picked=99, n=100 after fix\");\n\n        // Test case where 'picked' is at the boundary of `n`\n        GuessNumber.picked = n;\n        assertEquals(n, solution.guessNumber(n), \"Expected 'n' when picked is 'n' after fix\");\n\n        // Test case where 'picked' is 1\n        GuessNumber.picked = 1;\n        assertEquals(1, solution.guessNumber(n), \"Expected 1 when picked is 1 after fix\");\n    }\n}"}
{"issue": "19", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    private final HammingWeight solution = new HammingWeight();\n\n    @Test\n    void testPositiveNumbers() {\n        // These tests should pass whether the bug is present or fixed,\n        // as % 2 works correctly for positive numbers.\n        assertEquals(0, solution.hammingWeight(0), \"0 should have 0 bits\");\n        assertEquals(1, solution.hammingWeight(1), \"1 (0001) should have 1 bit\");\n        assertEquals(1, solution.hammingWeight(2), \"2 (0010) should have 1 bit\");\n        assertEquals(2, solution.hammingWeight(3), \"3 (0011) should have 2 bits\");\n        assertEquals(2, solution.hammingWeight(5), \"5 (0101) should have 2 bits\");\n        assertEquals(3, solution.hammingWeight(11), \"11 (1011) should have 3 bits\");\n        assertEquals(4, solution.hammingWeight(15), \"15 (1111) should have 4 bits\");\n        assertEquals(6, solution.hammingWeight(123), \"123 (01111011) should have 6 bits\");\n\n        // A larger positive number\n        assertEquals(10, solution.hammingWeight(Integer.MAX_VALUE), \"MAX_VALUE should have 31 bits\"); // 2^31 - 1, all ones except sign bit\n    }\n\n    @Test\n    void testNegativeNumbersWithBug() {\n        // These tests target the bug: n % 2 behaves differently for negative numbers.\n        // -1 (all ones in 2's complement) should have 32 bits.\n        // With n % 2, it often results in -1, leading to incorrect count.\n\n        // -1 in 2's complement is all 1s (32 ones)\n        // -1 % 2 = -1. This would make count -= 1 if using `count += n % 2` incorrectly, or just add 1 correctly\n        // if the result of % is always 0 or 1. But the behavior of `%` with negative numbers\n        // is `remainder = dividend - (dividend / divisor) * divisor`. So -1 % 2 is -1.\n        // -3 % 2 = -1\n        // -5 % 2 = -1\n        // The `count += n % 2` would effectively become `count -= 1` for odd negative numbers.\n        // For even negative numbers, `n % 2` is `0`, so it adds 0.\n\n        // This assertion might need adjustment based on how `n % 2` actually accumulates\n        // a typical incorrect output for -1 (all ones) would not be 32.\n        // Let's assume it leads to 0 or unexpected low numbers for simplicity of bug detection.\n        // In Java, `>>>` handles unsigned shift, so `-1 >>> 1` is a large positive number.\n        // The issue is purely `n % 2` for the *first* bit. After one shift, even -1 becomes a positive number.\n        // So the bug primarily affects the very first iteration for odd negative numbers.\n        // A common incorrect output for -1 due to this bug could be related to the first iteration adding -1.\n        // If `count` starts at 0, and first `count += -1 % 2` is `count += -1`, it becomes -1.\n        // The rest of the loop will add 0s or 1s, leading to an incorrect result.\n\n        // The expected value `0` or `1` is often used to assert for the buggy behavior in this case\n        // as the actual result of `n % 2` would be -1, making the sum potentially negative or incorrect.\n        // Let's expect it NOT to be 32, as that indicates the bug.\n        assertNotEquals(32, solution.hammingWeight(-1), \"-1 should NOT be 32 with the bug\");\n        assertNotEquals(31, solution.hammingWeight(Integer.MIN_VALUE), \"Integer.MIN_VALUE should NOT be 1 with the bug\"); // 100...0 (31 zeros, 1 one)\n    }\n\n    @Test\n    void testNegativeNumbersAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // -1 (all ones in 2's complement) should have 32 bits.\n        assertEquals(32, solution.hammingWeight(-1), \"-1 should have 32 bits after fix\");\n\n        // Integer.MIN_VALUE (100...0 in 2's complement) should have 1 bit (the sign bit).\n        assertEquals(1, solution.hammingWeight(Integer.MIN_VALUE), \"Integer.MIN_VALUE should have 1 bit after fix\");\n\n        // -3 (11...101 in 2's complement) should have 31 bits.\n        assertEquals(31, solution.hammingWeight(-3), \"-3 should have 31 bits after fix\");\n\n        // -2 (11...110 in 2's complement) should have 31 bits.\n        assertEquals(31, solution.hammingWeight(-2), \"-2 should have 31 bits after fix\");\n    }\n}"}
{"issue": "20", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    private final MaxProfit solution = new MaxProfit();\n\n    @Test\n    void testMaxProfitWithBug() {\n        // These tests expect the *buggy* behavior (maxProfit + 1)\n        // A fixed solution would make these assertions fail.\n\n        // Example 1: prices = {7,1,5,3,6,4}, max_profit = 5 (buy at 1, sell at 6)\n        // Buggy output: 5 + 1 = 6\n        assertEquals(6, solution.maxProfit(new int[]{7, 1, 5, 3, 6, 4}), \"Expected 6 for {7,1,5,3,6,4} due to bug\");\n\n        // Example 2: prices = {7,6,4,3,1}, max_profit = 0 (no transaction)\n        // Buggy output: 0 + 1 = 1\n        assertEquals(1, solution.maxProfit(new int[]{7, 6, 4, 3, 1}), \"Expected 1 for decreasing prices due to bug\");\n\n        // Example 3: prices = {1,2,3,4,5}, max_profit = 4 (buy at 1, sell at 5)\n        // Buggy output: 4 + 1 = 5\n        assertEquals(5, solution.maxProfit(new int[]{1, 2, 3, 4, 5}), \"Expected 5 for increasing prices due to bug\");\n\n        // Single element array\n        // minPrice = prices[0], loop doesn't run. maxProfit = 0.\n        // Buggy output: 0 + 1 = 1\n        assertEquals(1, solution.maxProfit(new int[]{5}), \"Expected 1 for single element array due to bug\");\n\n        // Two elements: {2, 1}. minPrice = 2, maxProfit = 0. Loop i=1: maxProfit = max(0, 1-2) = 0. minPrice = 1.\n        // Buggy output: 0 + 1 = 1\n        assertEquals(1, solution.maxProfit(new int[]{2, 1}), \"Expected 1 for {2,1} due to bug\");\n\n        // Two elements: {1, 2}. minPrice = 1, maxProfit = 0. Loop i=1: maxProfit = max(0, 2-1) = 1. minPrice = 1.\n        // Buggy output: 1 + 1 = 2\n        assertEquals(2, solution.maxProfit(new int[]{1, 2}), \"Expected 2 for {1,2} due to bug\");\n\n    }\n\n    @Test\n    void testMaxProfitAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // Example 1: prices = {7,1,5,3,6,4}, max_profit = 5\n        assertEquals(5, solution.maxProfit(new int[]{7, 1, 5, 3, 6, 4}), \"Expected 5 for {7,1,5,3,6,4} after fix\");\n\n        // Example 2: prices = {7,6,4,3,1}, max_profit = 0\n        assertEquals(0, solution.maxProfit(new int[]{7, 6, 4, 3, 1}), \"Expected 0 for decreasing prices after fix\");\n\n        // Example 3: prices = {1,2,3,4,5}, max_profit = 4\n        assertEquals(4, solution.maxProfit(new int[]{1, 2, 3, 4, 5}), \"Expected 4 for increasing prices after fix\");\n\n        // Single element array\n        assertEquals(0, solution.maxProfit(new int[]{5}), \"Expected 0 for single element array after fix\");\n\n        // Two elements: {2, 1}\n        assertEquals(0, solution.maxProfit(new int[]{2, 1}), \"Expected 0 for {2,1} after fix\");\n\n        // Two elements: {1, 2}\n        assertEquals(1, solution.maxProfit(new int[]{1, 2}), \"Expected 1 for {1,2} after fix\");\n\n        // Empty array - assuming problem constraints don't allow empty, or it returns 0\n        // Current code would throw ArrayIndexOutOfBoundsException. Need to handle.\n        // For robust testing, consider adding a try-catch for expected exceptions or input validation.\n        // If problem guarantees non-empty array, this test might not be necessary.\n        // For now, let's assume valid non-empty inputs based on current code structure.\n    }\n\n    @Test\n    void testEdgeCases() {\n        // Test with empty array (will cause ArrayIndexOutOfBoundsException with current code)\n        // Depending on problem specification, an empty array should return 0 or throw an exception.\n        // As the current code has `minPrice = prices[0]`, an empty array will crash.\n        // If the problem guarantees `prices.length >= 1`, this test is not strictly needed for the bug fix.\n        // If the problem allows empty arrays, the method `maxProfit` itself needs a check like `if (prices.length == 0) return 0;`\n        // This test case will fail due to exception if no fix is applied for empty array.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {\n            solution.maxProfit(new int[]{});\n        }, \"Empty array should throw ArrayIndexOutOfBoundsException if not handled\");\n\n        // Test with very large profit\n        assertEquals(999, solution.maxProfit(new int[]{1, 1000}), \"Expected 999 for {1,1000} after fix\");\n\n        // Test with multiple local minima/maxima\n        assertEquals(5, solution.maxProfit(new int[]{7, 6, 4, 3, 1, 8, 2, 10}), \"Complex scenario, peak profit (10-1=9) or (8-3=5)\");\n        // minPrice starts at 7. (8-1)=7, minPrice=1. (10-1)=9\n        // The greedy approach `maxProfit = Math.max(maxProfit, prices[i] - minPrice);` correctly finds the global max.\n        // For {7, 6, 4, 3, 1, 8, 2, 10}:\n        // i=1: prices[1]=6 < minPrice=7, minPrice=6, maxProfit=0\n        // i=2: prices[2]=4 < minPrice=6, minPrice=4, maxProfit=0\n        // i=3: prices[3]=3 < minPrice=4, minPrice=3, maxProfit=0\n        // i=4: prices[4]=1 < minPrice=3, minPrice=1, maxProfit=0\n        // i=5: prices[5]=8. maxProfit=max(0, 8-1)=7. minPrice=1.\n        // i=6: prices[6]=2. maxProfit=max(7, 2-1)=7. minPrice=1.\n        // i=7: prices[7]=10. maxProfit=max(7, 10-1)=9. minPrice=1.\n        // Correct maxProfit is 9.\n        // Buggy output: 9+1 = 10\n        assertEquals(10, solution.maxProfit(new int[]{7, 6, 4, 3, 1, 8, 2, 10}), \"Expected 10 for complex array due to bug\");\n\n    }\n}"}
{"issue": "21", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\n\npublic class SolutionTest {\n\n    private final MergeSortedArrays solution = new MergeSortedArrays();\n\n    @Test\n    void testMergeWithBug() {\n        // These tests specifically target the bug: the last element of nums2 might be missed.\n        // A fixed solution would make these assertions fail.\n\n        // Original example: nums1={1,2,3,0,0,0}, m=3, nums2={2,5,6}, n=3\n        // Expected correct: {1,2,2,3,5,6}\n        // With bug: If j becomes 0, nums2[0] (which is 2) is missed if loop condition is j > 0.\n        // In this case, 2 from nums2 is the first element, so it's handled by the first while loop.\n        // Let's create a case where nums2[0] is *not* handled by the first loop and causes the bug.\n\n        // Case 1: Smallest element from nums2 is at index 0 and needs to be copied after nums1 exhausted.\n        int[] nums1_1 = {4, 5, 6, 0, 0, 0};\n        int[] nums2_1 = {1, 2, 3};\n        solution.merge(nums1_1, 3, nums2_1, 3);\n        // Correct: {1,2,3,4,5,6}\n        // With bug: When i becomes -1, first loop exits. Second loop starts. j is 2. copies nums2[2], nums2[1].\n        // Then j becomes 0. Loop condition `j > 0` is false. nums2[0] (which is 1) is NOT copied.\n        assertFalse(Arrays.equals(new int[]{1, 2, 3, 4, 5, 6}, nums1_1), \"Expected to fail for {4,5,6,0,0,0}, {1,2,3} due to bug\");\n\n        // Case 2: nums1 is empty (m=0), nums2 has elements.\n        int[] nums1_2 = {0, 0, 0};\n        int[] nums2_2 = {1, 2, 3};\n        solution.merge(nums1_2, 0, nums2_2, 3);\n        // Correct: {1,2,3}\n        // With bug: i=-1 from start. First loop skipped. Second loop starts. j is 2. copies nums2[2], nums2[1].\n        // Then j becomes 0. Loop condition `j > 0` is false. nums2[0] (which is 1) is NOT copied.\n        assertFalse(Arrays.equals(new int[]{1, 2, 3}, nums1_2), \"Expected to fail for {0,0,0}, {1,2,3} due to bug\");\n\n        // Case 3: nums2 has only one element which is the smallest\n        int[] nums1_3 = {2, 0};\n        int[] nums2_3 = {1};\n        solution.merge(nums1_3, 1, nums2_3, 1);\n        // Correct: {1,2}\n        // With bug: i=0, j=0. Loop 1: nums1[0]=2 > nums2[0]=1 is false. nums1[k--]=nums2[j--] -> nums1[1]=1. k=0, j=-1.\n        // Oh, the first loop handles it if n is 1. We need j to be > 0 AND have elements to copy. Let's make it bigger.\n        int[] nums1_4 = {5, 6, 7, 0, 0, 0, 0};\n        int[] nums2_4 = {1, 2, 3, 4};\n        solution.merge(nums1_4, 3, nums2_4, 4);\n        // Correct: {1,2,3,4,5,6,7}\n        // With bug: The second loop (j > 0) would miss nums2[0]\n        assertFalse(Arrays.equals(new int[]{1, 2, 3, 4, 5, 6, 7}, nums1_4), \"Expected to fail for a larger case due to bug\");\n    }\n\n    @Test\n    void testMergeAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // Original example\n        int[] nums1_orig = {1, 2, 3, 0, 0, 0};\n        int[] nums2_orig = {2, 5, 6};\n        solution.merge(nums1_orig, 3, nums2_orig, 3);\n        assertArrayEquals(new int[]{1, 2, 2, 3, 5, 6}, nums1_orig, \"Original example after fix\");\n\n        // Case 1: Smallest element from nums2 is at index 0 and needs to be copied after nums1 exhausted.\n        int[] nums1_1 = {4, 5, 6, 0, 0, 0};\n        int[] nums2_1 = {1, 2, 3};\n        solution.merge(nums1_1, 3, nums2_1, 3);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6}, nums1_1, \"Case 1 after fix\");\n\n        // Case 2: nums1 is empty (m=0), nums2 has elements.\n        int[] nums1_2 = {0, 0, 0};\n        int[] nums2_2 = {1, 2, 3};\n        solution.merge(nums1_2, 0, nums2_2, 3);\n        assertArrayEquals(new int[]{1, 2, 3}, nums1_2, \"Case 2 after fix (nums1 empty)\");\n\n        // Case 3: nums2 is empty (n=0)\n        int[] nums1_3 = {1, 2, 3};\n        int[] nums2_3 = {}; // Empty nums2, n=0\n        solution.merge(nums1_3, 3, nums2_3, 0);\n        assertArrayEquals(new int[]{1, 2, 3}, nums1_3, \"Case 3 after fix (nums2 empty)\");\n\n        // Case 4: Both arrays have one element, nums2[0] < nums1[0]\n        int[] nums1_4 = {2, 0};\n        int[] nums2_4 = {1};\n        solution.merge(nums1_4, 1, nums2_4, 1);\n        assertArrayEquals(new int[]{1, 2}, nums1_4, \"Case 4 after fix\");\n\n        // Case 5: Both arrays have one element, nums2[0] > nums1[0]\n        int[] nums1_5 = {1, 0};\n        int[] nums2_5 = {2};\n        solution.merge(nums1_5, 1, nums2_5, 1);\n        assertArrayEquals(new int[]{1, 2}, nums1_5, \"Case 5 after fix\");\n\n        // Case 6: Larger arrays, interleave\n        int[] nums1_6 = {1, 3, 5, 7, 0, 0, 0, 0};\n        int[] nums2_6 = {2, 4, 6, 8};\n        solution.merge(nums1_6, 4, nums2_6, 4);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6, 7, 8}, nums1_6, \"Larger interleaved arrays after fix\");\n\n        // Case 7: All elements from nums2 are larger than nums1\n        int[] nums1_7 = {1, 2, 3, 0, 0, 0};\n        int[] nums2_7 = {4, 5, 6};\n        solution.merge(nums1_7, 3, nums2_7, 3);\n        assertArrayEquals(new int[]{1, 2, 3, 4, 5, 6}, nums1_7, \"All nums2 larger after fix\");\n\n        // Case 8: All elements from nums2 are smaller than nums1\n        int[] nums1_8 = {7, 8, 9, 0, 0, 0};\n        int[] nums2_8 = {1, 2, 3};\n        solution.merge(nums1_8, 3, nums2_8, 3);\n        assertArrayEquals(new int[]{1, 2, 3, 7, 8, 9}, nums1_8, \"All nums2 smaller after fix\");\n    }\n}"}
{"issue": "22","test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\nimport java.util.Arrays;\n\npublic class SolutionTest {\n\n    private final PlusOne solution = new PlusOne();\n\n    @Test\n    void testPlusOneStandardCases() {\n        // These tests should pass whether the bug is present or fixed,\n        // as they don't trigger the "all-nines" edge case.\n\n        // Single digit, no carry\n        assertArrayEquals(new int[]{2}, solution.plusOne(new int[]{1}), \"{1} -> {2}\");\n\n        // Multiple digits, no carry\n        assertArrayEquals(new int[]{1, 2, 4}, solution.plusOne(new int[]{1, 2, 3}), \"{1,2,3} -> {1,2,4}\");\n\n        // Single digit, with carry (but not all-nines)\n        assertArrayEquals(new int[]{1, 0}, solution.plusOne(new int[]{9}), \"{9} -> {1,0} (This is an all-nines case, but handled here)\");\n        // The original code actually handles `[9]` correctly because it returns early after creating `[0]`.        // However, for `[9,9]` it will fail.        // Let's refine this to specifically target where the bug affects.\n\n        // Multiple digits, with carry in the middle\n        assertArrayEquals(new int[]{4, 3, 0}, solution.plusOne(new int[]{4, 2, 9}), \"{4,2,9} -> {4,3,0}\");\n        assertArrayEquals(new int[]{1, 2, 3, 4, 6}, solution.plusOne(new int[]{1, 2, 3, 4, 5}), \"{1,2,3,4,5} -> {1,2,3,4,6}\");\n\n    }\n\n    @Test\n    void testPlusOneAllNinesWithBug() {\n        // These tests specifically target the bug: when all digits are 9.\n        // With the bug, these will return an incorrect array of zeros with the original length.\n\n        // {9,9} -> Correct: {1,0,0}. Buggy: {0,0}\n        assertFalse(Arrays.equals(new int[]{1, 0, 0}, solution.plusOne(new int[]{9, 9})), \"Expected to fail for {9,9} due to bug\");\n\n        // {9,9,9} -> Correct: {1,0,0,0}. Buggy: {0,0,0}\n        assertFalse(Arrays.equals(new int[]{1, 0, 0, 0}, solution.plusOne(new int[]{9, 9, 9})), \"Expected to fail for {9,9,9} due to bug\");\n\n        // {9,9,9,9} -> Correct: {1,0,0,0,0}. Buggy: {0,0,0,0}\n        assertFalse(Arrays.equals(new int[]{1, 0, 0, 0, 0}, solution.plusOne(new int[]{9, 9, 9, 9})), \"Expected to fail for {9,9,9,9} due to bug\");\n    }\n\n    @Test\n    void testPlusOneAllNinesAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // {9,9} -> {1,0,0}\n        assertArrayEquals(new int[]{1, 0, 0}, solution.plusOne(new int[]{9, 9}), \"{9,9} -> {1,0,0} after fix\");\n\n        // {9,9,9} -> {1,0,0,0}\n        assertArrayEquals(new int[]{1, 0, 0, 0}, solution.plusOne(new int[]{9, 9, 9}), \"{9,9,9} -> {1,0,0,0} after fix\");\n\n        // {9,9,9,9} -> {1,0,0,0,0}\n        assertArrayEquals(new int[]{1, 0, 0, 0, 0}, solution.plusOne(new int[]{9, 9, 9, 9}), \"{9,9,9,9} -> {1,0,0,0,0} after fix\");\n\n        // {0} -> {1}\n        assertArrayEquals(new int[]{1}, solution.plusOne(new int[]{0}), \"{0} -> {1} (edge case)\");\n    }\n\n    @Test\n    void testPlusOneEdgeCases() {\n        // Empty array - The current code does not handle this gracefully (ArrayIndexOutOfBoundsException)\n        // A robust solution would add: `if (digits == null || digits.length == 0) return new int[]{1};`\n        // This test will fail if the method is called with an empty array without such a check.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {\n            solution.plusOne(new int[]{});\n        }, \"Empty array should throw ArrayIndexOutOfBoundsException if not handled\");\n    }\n}"}
{"issue": "23", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    private final PowerOfThree solution = new PowerOfThree();\n\n    @Test\n    void testIsPowerOfThreeWithBug() {\n        // These tests expect the *buggy* behavior (returns true if n becomes 3 after division, false otherwise)\n        // A fixed solution would make these assertions fail.\n\n        // 3^0 = 1. Buggy: loop doesn't run, n=1. returns 1==3 (false). Correct: true.\n        assertFalse(solution.isPowerOfThree(1), \"Expected false for 1 due to bug\");\n\n        // 3^1 = 3. Buggy: loop doesn't run, n=3. returns 3==3 (true). Correct: true.\n        assertTrue(solution.isPowerOfThree(3), \"Expected true for 3 (correct by chance due to bug)\");\n\n        // 3^2 = 9. Buggy: n=9 -> n=3. returns 3==3 (true). Correct: true.\n        assertTrue(solution.isPowerOfThree(9), \"Expected true for 9 due to bug\");\n\n        // 3^3 = 27. Buggy: n=27 -> n=9 -> n=3. returns 3==3 (true). Correct: true.\n        assertTrue(solution.isPowerOfThree(27), \"Expected true for 27 due to bug\");\n\n        // 3^4 = 81. Buggy: n=81 -> n=27 -> n=9 -> n=3. returns 3==3 (true). Correct: true.\n        assertTrue(solution.isPowerOfThree(81), \"Expected true for 81 due to bug\");\n\n        // Non-power of three\n        // 2: Buggy: loop doesn't run, n=2. returns 2==3 (false). Correct: false.\n        assertFalse(solution.isPowerOfThree(2), \"Expected false for 2 (correctly returns false even with bug)\");\n\n        // 5: Buggy: loop doesn't run, n=5. returns 5==3 (false). Correct: false.\n        assertFalse(solution.isPowerOfThree(5), \"Expected false for 5 (correctly returns false even with bug)\");\n\n        // 6: Buggy: n=6 -> n=2. returns 2==3 (false). Correct: false.\n        assertFalse(solution.isPowerOfThree(6), \"Expected false for 6 (correctly returns false even with bug)\");\n\n        // 0: Buggy: loop condition n > 0 is false. returns 0==3 (false). Correct: false.\n        assertFalse(solution.isPowerOfThree(0), \"Expected false for 0 (correctly returns false even with bug)\");\n\n        // Negative numbers: Buggy: loop condition n > 0 is false. returns n==3 (false). Correct: false.\n        assertFalse(solution.isPowerOfThree(-1), \"Expected false for -1 (correctly returns false even with bug)\");\n        assertFalse(solution.isPowerOfThree(-9), \"Expected false for -9 (correctly returns false even with bug)\");\n    }\n\n    @Test\n    void testIsPowerOfThreeAfterFix() {\n        // These tests are designed to check the *correct* behavior after the bug is fixed.\n        // If the bug is *not* fixed, these tests will FAIL.\n\n        // 3^0 = 1\n        assertTrue(solution.isPowerOfThree(1), \"Expected true for 1 after fix\");\n\n        // 3^1 = 3\n        assertTrue(solution.isPowerOfThree(3), \"Expected true for 3 after fix\");\n\n        // 3^2 = 9\n        assertTrue(solution.isPowerOfThree(9), \"Expected true for 9 after fix\");\n\n        // 3^3 = 27\n        assertTrue(solution.isPowerOfThree(27), \"Expected true for 27 after fix\");\n\n        // 3^4 = 81\n        assertTrue(solution.isPowerOfThree(81), \"Expected true for 81 after fix\");\n\n        // Max power of 3 within int range (3^19 = 1162261467)\n        assertTrue(solution.isPowerOfThree(1162261467), \"Expected true for max power of 3 after fix\");\n\n        // Non-power of three\n        assertFalse(solution.isPowerOfThree(2), \"Expected false for 2 after fix\");\n        assertFalse(solution.isPowerOfThree(4), \"Expected false for 4 after fix\");\n        assertFalse(solution.isPowerOfThree(5), \"Expected false for 5 after fix\");\n        assertFalse(solution.isPowerOfThree(6), \"Expected false for 6 after fix\");\n        assertFalse(solution.isPowerOfThree(0), \"Expected false for 0 after fix\");\n        assertFalse(solution.isPowerOfThree(-1), \"Expected false for -1 after fix\");\n        assertFalse(solution.isPowerOfThree(Integer.MAX_VALUE), \"Expected false for MAX_VALUE after fix\");\n        assertFalse(solution.isPowerOfThree(Integer.MIN_VALUE), \"Expected false for MIN_VALUE after fix\");\n    }\n}"}
{"issue": "24", "test": "import org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.*;\n\npublic class SolutionTest {\n\n    private final ToLowerCase solution = new ToLowerCase();\n\n    @Test\n    void testToLowerCaseStandardCases() {\n        // These tests should produce correct output if the bug is fixed.\n        // If the bug is present, they will crash with ArrayIndexOutOfBoundsException.\n\n        assertEquals(\"hello\", solution.toLowerCase(\"Hello\"), \"'Hello' should become 'hello'\");\n        assertEquals(\"world\", solution.toLowerCase(\"WORLD\"), \"'WORLD' should become 'world'\");\n        assertEquals(\"abc\", solution.toLowerCase(\"abc\"), \"'abc' should remain 'abc'\");\n        assertEquals(\"123!@#\", solution.toLowerCase(\"123!@#\"), \"Non-alphabetic characters should remain unchanged\");\n        assertEquals(\"lowercase letters remain unchanged\", solution.toLowerCase(\"lowercase letters remain unchanged\"), \"Lowercase letters should remain unchanged\");\n        assertEquals(\"mixofCASEs\", solution.toLowerCase(\"MixOfCASEs\"), \"Mixed case string should be fully lowercased\");\n    }\n\n    @Test\n    void testToLowerCaseWithBugExpectedException() {\n        // This test specifically targets the bug. It expects an ArrayIndexOutOfBoundsException.\n        // If the bug is fixed, this test will FAIL because the exception will not be thrown.\n\n        // Test case where the bug (i <= arr.length) will cause an error.\n        // Any non-empty string will trigger this.\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {\n            solution.toLowerCase(\"a\");\n        }, \"Single char string should cause ArrayIndexOutOfBoundsException due to bug\");\n\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {\n            solution.toLowerCase(\"LongString\");\n        }, \"Longer string should cause ArrayIndexOutOfBoundsException due to bug\");\n\n        // The `main` method's example will also cause this crash:\n        assertThrows(ArrayIndexOutOfBoundsException.class, () -> {\n            solution.toLowerCase(\"HelLoWorLD\");\n        }, \"Main method's example should cause ArrayIndexOutOfBoundsException due to bug\");\n\n    }\n\n    @Test\n    void testEdgeCasesAfterFix() {\n        // These tests ensure edge cases are handled correctly after the bug is fixed.\n        // If the bug is *not* fixed, these tests will throw an exception and fail.\n\n        // Empty string\n        assertEquals(\"\", solution.toLowerCase(\"\"), \"Empty string should remain empty\");\n\n        // Single character string (capital)\n        assertEquals(\"a\", solution.toLowerCase(\"A\"), \"Single capital char 'A' should become 'a'\");\n\n        // Single character string (lowercase)\n        assertEquals(\"z\", solution.toLowerCase(\"z\"), \"Single lowercase char 'z' should remain 'z'\");\n\n        // String with only special characters/numbers\n        assertEquals(\"!@#$123\", solution.toLowerCase(\"!@#$123\"), \"String with only special chars/numbers\");\n    }\n}"}
{"issue": "25", "test": "#include <iostream>\n#include <vector>\n#include <numeric> // For std::iota if needed for test data generation\n#include <algorithm> // For std::find if needed for debugging\n\n// The function to be tested (with the known bug)\nint binarySearch(const std::vector<int>& nums, int target) {\n    int left = 0, right = nums.size() - 1;\n    while (left <= right) {\n        int mid = (left + right + 1) / 2; // Bug: Should be (left + right) / 2 or left + (right - left) / 2\n        // The bug here is that it always biases 'mid' towards the right (upper bound).\n        // If `left` and `right` are, for example, `0` and `1`, `mid` becomes `1`. \n        // If target is `nums[0]` (e.g., target=1, nums={1,2}), and mid=1 (nums[1]=2), then right becomes 0. \n        // Next iteration: left=0, right=0. mid becomes 0. nums[0] is target. Correctly returns 0. \n        // The bug is subtle. It primarily causes an issue when `target` is the smallest element and the array is {smallest, larger}, \n        // or if `mid` calculation combined with `right = mid - 1` or `left = mid + 1` leads to an infinite loop.\n        // The common infinite loop with `(left + right + 1) / 2` is when `target` is not found and `left` can never become greater than `right`.\n        // For example, if target is too small, and `right` keeps getting `mid - 1`.\n        // Let's test with a simple case to demonstrate the issue.\n\n        if (nums[mid] == target) return mid;\n        else if (nums[mid] < target) left = mid + 1;\n        else right = mid - 1;\n    }\n    return -1;\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Target found in middle (should pass even with bug sometimes)\n    std::vector<int> nums1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int target1 = 5;\n    int result1 = binarySearch(nums1, target1);\n    if (result1 != 4) {\n        std::cout << \"Test Case 1 FAILED (Buggy, expected 4, got \" << result1 << \"): Target found in middle\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 PASSED (as expected or by chance with bug)\\n\";\n    }\n\n    // Test Case 2: Target at the beginning (more likely to expose bug)\n    std::vector<int> nums2 = {1, 3, 5, 7, 9};\n    int target2 = 1;\n    int result2 = binarySearch(nums2, target2);\n    // With `mid = (left + right + 1) / 2`:\n    // l=0, r=4 -> mid=(0+4+1)/2 = 2. nums[2]=5. 5 > 1 -> right = 2-1 = 1.\n    // l=0, r=1 -> mid=(0+1+1)/2 = 1. nums[1]=3. 3 > 1 -> right = 1-1 = 0.\n    // l=0, r=0 -> mid=(0+0+1)/2 = 0. nums[0]=1. 1 == 1 -> returns 0. (Passes by chance here)\n    // This particular bug (mid always rounded up) makes it hard to create a failing test on typical inputs easily.\n    // The primary reason for `(left + right) / 2` over `(left + right + 1) / 2` is to prevent infinite loops in specific non-found scenarios, \n    // or when `right = mid - 1` and `left = mid` (or vice versa) is used, which is not the case here.\n    // The current bug mostly influences performance/path taken, not necessarily correctness for simple cases.\n    // Let's create a test that specifically targets when it might fail or loop. \n    // The most common infinite loop for `(left + right + 1) / 2` is when `else right = mid` is used instead of `right = mid - 1`.\n    // Given `right = mid - 1`, it actually functions correctly for most found cases, but the search path is different.\n    // The "bug" here is more about potential for off-by-one errors in logic or performance, not always a direct wrong answer.\n\n    // Let's create a scenario where the target is not found, and `mid = (left + right + 1) / 2` causes `left` to pass `right` incorrectly.\n    std::vector<int> nums_bug = {1, 2, 4, 5}; // No 3\n    int target_bug = 3;\n    int result_bug = binarySearch(nums_bug, target_bug);\n    // l=0, r=3 -> mid=(0+3+1)/2 = 2. nums[2]=4. 4 > 3 -> right = 2-1 = 1.\n    // l=0, r=1 -> mid=(0+1+1)/2 = 1. nums[1]=2. 2 < 3 -> left = 1+1 = 2.\n    // l=2, r=1. loop condition (left <= right) is false. returns -1. (Correctly handles not found)\n\n    // Okay, the `(left + right + 1) / 2` when used with `right = mid - 1` is primarily used when `left = mid` is the alternative, not `left = mid + 1`.\n    // For this specific variant of binary search (where target found directly `mid == target`), `(left + right + 1) / 2` works fine.\n    // The bug is usually when `left = mid` is used on one branch and `right = mid - 1` on another without `+1` on `mid` to guarantee progress.\n    // Let's test the intended fix of `(left + right) / 2` vs the current `(left + right + 1) / 2` behavior for subtle differences.\n    // The main issue with `(left + right + 1) / 2` with `right = mid - 1` is when `target` is not found, and `left` becomes `right + 1`. This should return -1.\n    // For example, if nums={1,3}, target=2.\n    // l=0, r=1 -> mid=(0+1+1)/2 = 1. nums[1]=3. 3 > 2 -> right = 1-1 = 0.\n    // l=0, r=0 -> mid=(0+0+1)/2 = 0. nums[0]=1. 1 < 2 -> left = 0+1 = 1.\n    // l=1, r=0. loop condition (left <= right) is false. returns -1. (Correctly handles not found)\n    // It seems this bug might not cause incorrectness in standard search, but is a "code style" bug for consistency with certain binary search patterns.\n    // However, it *could* cause issues if `right` is `INT_MAX` or `left` is `INT_MIN` leading to overflow on `left + right`.\n    // A safer mid calculation is `left + (right - left) / 2` to avoid `left + right` overflow.\n\n    // The prompt says `// Bug: Should be (left + right) / 2`. Let's test for what would be different.\n    // The critical difference is when `left + right` is odd. `(X)/2` truncates.\n    // e.g., l=0, r=2. (0+2)/2=1. (0+2+1)/2=1. (No difference here)\n    // e.g., l=0, r=1. (0+1)/2=0. (0+1+1)/2=1. (Difference!)\n    // If mid=0, and target=nums[1], then left=1. Next iteration: l=1, r=1. Then mid=1. Works.\n    // If mid=1, and target=nums[0], then right=0. Next iteration: l=0, r=0. Then mid=0. Works.\n\n    // The actual common bug with `(left + right + 1) / 2` is when you have `left = mid;` on one branch, and `right = mid - 1` on the other.\n    // E.g., `while (left < right)` loop. If `nums[mid] < target`, you might do `left = mid;`.\n    // In *this specific code*, the bug is less about correctness for finding an element, but more about stylistic correctness or potential for subtle off-by-one errors in boundary conditions or not-found cases, or for overflow for very large indices.\n    // Let's assume the problem means it *could* lead to incorrect behavior for *some* test cases, even if not immediately obvious for simple ones.\n\n    // Let's create a test that fails due to `+1` causing `mid` to be wrong for `right = mid - 1` when `target` is not found.\n    // With target = 4, nums={1,3,5,7,9}\n    // l=0, r=4. mid=(0+4+1)/2 = 2 (value 5). target=4. 5 > 4. right = 2-1 = 1.\n    // l=0, r=1. mid=(0+1+1)/2 = 1 (value 3). target=4. 3 < 4. left = 1+1 = 2.\n    // l=2, r=1. loop ends. returns -1. (This is correct for not found).\n\n    // The bug note likely implies that for some array and target where `target` is not present, \n    // the current `mid` calculation might lead to an incorrect `-1` or an infinite loop when it shouldn't.\n    // Or that `mid = (left + right + 1) / 2` paired with `left = mid + 1` and `right = mid - 1` (as seen here) \n    // is an unconventional choice which might cause issues in certain scenarios.\n    // The most robust mid calculation is `left + (right - left) / 2` to avoid `int` overflow for `left + right`.\n\n    // Since the bug is stated as `(left + right + 1) / 2` should be `(left + right) / 2`,\n    // let's test for cases where the behavior would actually differ and lead to an incorrect result.\n    // Consider target not found, with just two elements, e.g., nums={1, 5}, target=3.\n    // l=0, r=1. mid=(0+1+1)/2 = 1. nums[1]=5. 5 > 3. right = 1-1 = 0.\n    // l=0, r=0. mid=(0+0+1)/2 = 0. nums[0]=1. 1 < 3. left = 0+1 = 1.\n    // l=1, r=0. loop ends. returns -1. (Correctly handles not found).\n    // This is surprisingly hard to break with just this `+1` in mid and `left+1/right-1`.\n    // This bug is more about the context of standard binary search implementations than a direct functional flaw here.\n    // However, if the intent is to avoid the `+1` behavior, we must test for that specific difference.\n\n    // Let's test for cases where the target should be found, but the `+1` makes it skip.\n    // This means `mid` would point to the *next* element, and if that's not the target, `target` might be skipped.\n    // Example: nums={1,2,3,4}, target=2\n    // l=0, r=3 -> mid=(0+3+1)/2 = 2. nums[2]=3. target=2. 3 > 2 -> right = 2-1 = 1.\n    // l=0, r=1 -> mid=(0+1+1)/2 = 1. nums[1]=2. target=2. 2 == 2 -> returns 1. (Works)\n\n    // Okay, the bug is subtle. Let's assume `(left + right + 1) / 2` is buggy because it might lead to non-optimal paths or unexpected outcomes in complex scenarios not immediately obvious.\n    // A very common infinite loop scenario involves: `while (left < right)`, `mid = (left + right) / 2`, `left = mid + 1` and `right = mid`.\n    // OR `while (left < right)`, `mid = (left + right + 1) / 2`, `left = mid` and `right = mid - 1`.\n    // The current code is `while (left <= right)`, `mid = (left + right + 1) / 2`, `left = mid + 1` / `right = mid - 1`.\n    // This structure *typically* works correctly for finding elements and returning -1 for not found.\n    // The main "bug" of `(left + right + 1) / 2` is often linked to infinite loops when `left = mid` is chosen, not `left = mid + 1`.\n    // If the problem setters say it's a bug, it's likely a subtle edge case or theoretical one related to binary search properties.\n    // The easiest way to *force* a failure with the `+1` is to make `target` such that `(left + right + 1) / 2` causes `mid` to skip it.\n    // But given `if (nums[mid] == target) return mid;` and the adjustments, it should find it.\n\n    // Let's test the main reason for `(left + right + 1) / 2` vs `(left + right) / 2`:\n    // When `left = mid + 1`, `right = mid - 1`, use `(left + right) / 2`.\n    // When `left = mid`, `right = mid - 1` (or similar), use `(left + right + 1) / 2`.\n    // The code mixes `(left + right + 1) / 2` with `left = mid + 1` and `right = mid - 1`. This is unconventional.\n    // The bug is likely this unconventional pairing, which *can* cause infinite loops or incorrect results in very specific (often `target` not found) edge cases.\n\n    // Test Case 2: Target not found, single element interval (bug might lead to infinite loop if `mid` doesn't move)\n    std::vector<int> nums2 = {1}; // target = 0\n    int target2 = 0;\n    int result2 = binarySearch(nums2, target2);\n    // l=0, r=0 -> mid=(0+0+1)/2 = 0. nums[0]=1. 1 > 0 -> right = 0-1 = -1.\n    // l=0, r=-1. loop ends. returns -1. (Correct).\n\n    // It's genuinely difficult to find a standard test case that makes `(left + right + 1) / 2` with `left = mid + 1` and `right = mid - 1` directly fail for a `found` target. \n    // The problem statement implying it's a bug with `+1` might be subtle: potentially overflow for extremely large arrays, or issues with specific `target` not being found. \n    // Let's write tests to confirm the "correct" behavior and then assume the bug is fixed if these pass.\n\n    // --- After Fix tests (expect the standard behavior) ---\n\n    // Test Case for correct target in middle\n    std::vector<int> nums_correct1 = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};\n    int target_correct1 = 5;\n    int expected_idx1 = 4;\n    int actual_idx1 = binarySearch(nums_correct1, target_correct1);\n    if (actual_idx1 != expected_idx1) {\n        std::cout << \"Test Case Correct 1 FAILED: Expected \" << expected_idx1 << \", got \" << actual_idx1 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 1 PASSED\\n\";\n    }\n\n    // Test Case for target at beginning\n    std::vector<int> nums_correct2 = {1, 3, 5, 7, 9};\n    int target_correct2 = 1;\n    int expected_idx2 = 0;\n    int actual_idx2 = binarySearch(nums_correct2, target_correct2);\n    if (actual_idx2 != expected_idx2) {\n        std::cout << \"Test Case Correct 2 FAILED: Expected \" << expected_idx2 << \", got \" << actual_idx2 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 2 PASSED\\n\";\n    }\n\n    // Test Case for target at end\n    std::vector<int> nums_correct3 = {1, 3, 5, 7, 9};\n    int target_correct3 = 9;\n    int expected_idx3 = 4;\n    int actual_idx3 = binarySearch(nums_correct3, target_correct3);\n    if (actual_idx3 != expected_idx3) {\n        std::cout << \"Test Case Correct 3 FAILED: Expected \" << expected_idx3 << \", got \" << actual_idx3 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 3 PASSED\\n\";\n    }\n\n    // Test Case for target not found (odd length array)\n    std::vector<int> nums_correct4 = {1, 3, 5, 7, 9};\n    int target_correct4 = 4;\n    int expected_idx4 = -1;\n    int actual_idx4 = binarySearch(nums_correct4, target_correct4);\n    if (actual_idx4 != expected_idx4) {\n        std::cout << \"Test Case Correct 4 FAILED: Expected \" << expected_idx4 << \", got \" << actual_idx4 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 4 PASSED\\n\";\n    }\n\n    // Test Case for target not found (even length array)\n    std::vector<int> nums_correct5 = {1, 2, 6, 8};\n    int target_correct5 = 3;\n    int expected_idx5 = -1;\n    int actual_idx5 = binarySearch(nums_correct5, target_correct5);\n    if (actual_idx5 != expected_idx5) {\n        std::cout << \"Test Case Correct 5 FAILED: Expected \" << expected_idx5 << \", got \" << actual_idx5 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 5 PASSED\\n\";\n    }\n\n    // Test Case for empty array\n    std::vector<int> nums_correct6 = {};\n    int target_correct6 = 5;\n    int expected_idx6 = -1;\n    int actual_idx6 = binarySearch(nums_correct6, target_correct6);\n    if (actual_idx6 != expected_idx6) {\n        std::cout << \"Test Case Correct 6 FAILED: Expected \" << expected_idx6 << \", got \" << actual_idx6 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 6 PASSED\\n\";\n    }\n\n    // Test Case for single element array (target found)\n    std::vector<int> nums_correct7 = {10};\n    int target_correct7 = 10;\n    int expected_idx7 = 0;\n    int actual_idx7 = binarySearch(nums_correct7, target_correct7);\n    if (actual_idx7 != expected_idx7) {\n        std::cout << \"Test Case Correct 7 FAILED: Expected \" << expected_idx7 << \", got \" << actual_idx7 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 7 PASSED\\n\";\n    }\n\n    // Test Case for single element array (target not found)\n    std::vector<int> nums_correct8 = {10};\n    int target_correct8 = 5;\n    int expected_idx8 = -1;\n    int actual_idx8 = binarySearch(nums_correct8, target_correct8);\n    if (actual_idx8 != expected_idx8) {\n        std::cout << \"Test Case Correct 8 FAILED: Expected \" << expected_idx8 << \", got \" << actual_idx8 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 8 PASSED\\n\";\n    }\n\n    // Test Case for two elements (target found)\n    std::vector<int> nums_correct9 = {5, 10};\n    int target_correct9 = 5;\n    int expected_idx9 = 0;\n    int actual_idx9 = binarySearch(nums_correct9, target_correct9);\n    if (actual_idx9 != expected_idx9) {\n        std::cout << \"Test Case Correct 9 FAILED: Expected \" << expected_idx9 << \", got \" << actual_idx9 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 9 PASSED\\n\";\n    }\n\n    // Test Case for two elements (target not found)\n    std::vector<int> nums_correct10 = {5, 10};\n    int target_correct10 = 7;\n    int expected_idx10 = -1;\n    int actual_idx10 = binarySearch(nums_correct10, target_correct10);\n    if (actual_idx10 != expected_idx10) {\n        std::cout << \"Test Case Correct 10 FAILED: Expected \" << expected_idx10 << \", got \" << actual_idx10 << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case Correct 10 PASSED\\n\";\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the corrected logic.\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the binarySearch implementation.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "26", "test": "#include <iostream>\n#include <vector>\n#include <cassert> // For assert\n\n// The function to be tested (with the known bug)\nint climbStairs(int n) {\n    if (n <= 1) return 1;\n    int a = 1, b = 1, c = 0; // a represents F(i-2), b represents F(i-1)\n    // F(0)=1, F(1)=1 (base cases for n=0 and n=1 steps)\n    // F(2) = F(1) + F(0) = 1 + 1 = 2\n    // F(3) = F(2) + F(1) = 2 + 1 = 3\n    // F(4) = F(3) + F(2) = 3 + 2 = 5\n\n    for (int i = 2; i < n; ++i) { // Bug: should be i <= n\n        c = a + b;\n        a = b;\n        b = c;\n    }\n    return b; // This will return F(n-1) due to the loop condition\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: n = 0\n    // Correct: 1 (There's 1 way to climb 0 steps: do nothing)\n    // Buggy: returns 1 (correctly, as if n=1)\n    if (climbStairs(0) != 1) {\n        std::cout << \"Test Case 1 FAILED: n=0. Expected 1, Got \" << climbStairs(0) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 PASSED: n=0.\\n\";\n    }\n\n    // Test Case 2: n = 1\n    // Correct: 1\n    // Buggy: returns 1 (correctly)\n    if (climbStairs(1) != 1) {\n        std::cout << \"Test Case 2 FAILED: n=1. Expected 1, Got \" << climbStairs(1) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 2 PASSED: n=1.\\n\";\n    }\n\n    // Test Case 3: n = 2\n    // Correct: 2 (1+1, 2)\n    // Buggy: loop `for (int i = 2; i < 2; ++i)` doesn't run. Returns `b` which is 1. (Incorrect)\n    if (climbStairs(2) != 1) { // Expect 1 due to bug\n        std::cout << \"Test Case 3 FAILED (Buggy): n=2. Expected 1, Got \" << climbStairs(2) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 3 PASSED (as expected with bug): n=2.\\n\";\n    }\n\n    // Test Case 4: n = 3\n    // Correct: 3 (1+1+1, 1+2, 2+1)\n    // Buggy: loop `for (int i = 2; i < 3; ++i)` runs once for i=2. c=a+b=1+1=2. a=1, b=2. Returns `b` which is 2. (Incorrect)\n    if (climbStairs(3) != 2) { // Expect 2 due to bug\n        std::cout << \"Test Case 4 FAILED (Buggy): n=3. Expected 2, Got \" << climbStairs(3) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 4 PASSED (as expected with bug): n=3.\\n\";\n    }\n\n    // Test Case 5: n = 4 (from main)\n    // Correct: 5\n    // Buggy: loop runs for i=2, i=3. Calculates F(3) and returns it. (Incorrect)\n    if (climbStairs(4) != 3) { // Expect 3 due to bug (F(3))\n        std::cout << \"Test Case 5 FAILED (Buggy): n=4. Expected 3, Got \" << climbStairs(4) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 5 PASSED (as expected with bug): n=4.\\n\";\n    }\n\n    // Test Case 6: n = 5\n    // Correct: 8\n    // Buggy: returns F(4) = 5. (Incorrect)\n    if (climbStairs(5) != 5) { // Expect 5 due to bug (F(4))\n        std::cout << \"Test Case 6 FAILED (Buggy): n=5. Expected 5, Got \" << climbStairs(5) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 6 PASSED (as expected with bug): n=5.\\n\";\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., loop condition is `i <= n`) ---\n\n    // Test Case 7: n = 2 (after fix)\n    // Correct: 2\n    if (climbStairs(2) != 2) {\n        std::cout << \"Test Case 7 FAILED (After Fix): n=2. Expected 2, Got \" << climbStairs(2) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 7 PASSED (After Fix): n=2.\\n\";\n    }\n\n    // Test Case 8: n = 3 (after fix)\n    // Correct: 3\n    if (climbStairs(3) != 3) {\n        std::cout << \"Test Case 8 FAILED (After Fix): n=3. Expected 3, Got \" << climbStairs(3) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 8 PASSED (After Fix): n=3.\\n\";\n    }\n\n    // Test Case 9: n = 4 (after fix)\n    // Correct: 5\n    if (climbStairs(4) != 5) {\n        std::cout << \"Test Case 9 FAILED (After Fix): n=4. Expected 5, Got \" << climbStairs(4) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 9 PASSED (After Fix): n=4.\\n\";\n    }\n\n    // Test Case 10: n = 10\n    // Correct: F(10) = 89\n    if (climbStairs(10) != 89) {\n        std::cout << \"Test Case 10 FAILED (After Fix): n=10. Expected 89, Got \" << climbStairs(10) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 10 PASSED (After Fix): n=10.\\n\";\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the climbStairs implementation or expected outputs for the bug.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "27", "test": "#include <iostream>\n#include <vector>\n#include <string>\n#include <cassert>\n\n// The function to be tested (with the known bug)\nstd::vector<std::string> fizzBuzz(int n) {\n    std::vector<std::string> result;\n    for (int i = 1; i <= n; ++i) {\n        if (i % 3 == 0) result.push_back(\"Fizz\");\n        else if (i % 5 == 0) result.push_back(\"Buzz\");\n        else if (i % 15 == 0) result.push_back(\"FizzBuzz\"); // Bug: This never triggers\n        else result.push_back(std::to_string(i));\n    }\n    return result;\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: n = 15 (classic FizzBuzz range, exposes bug)\n    std::vector<std::string> result1 = fizzBuzz(15);\n    std::vector<std::string> expected1_buggy = {\n        \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\",\n        \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\",\n        \"11\", \"Fizz\", \"13\", \"14\", \"Fizz\" // Should be FizzBuzz at 15\n    };\n    std::vector<std::string> expected1_fixed = {\n        \"1\", \"2\", \"Fizz\", \"4\", \"Buzz\",\n        \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\",\n        \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"\n    };\n\n    if (result1 == expected1_buggy) {\n        std::cout << \"Test Case 1 PASSED (as expected with bug): n=15. Result matches buggy output.\\n\";\n    } else if (result1 == expected1_fixed) {\n        std::cout << \"Test Case 1 FAILED (Bug fixed): n=15. Result matches fixed output.\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 FAILED (Unexpected output): n=15.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 2: n = 5 (no FizzBuzz, standard Fizz/Buzz/numbers)\n    std::vector<std::string> result2 = fizzBuzz(5);\n    std::vector<std::string> expected2 = {\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\"};\n    if (result2 == expected2) {\n        std::cout << \"Test Case 2 PASSED: n=5.\\n\";\n    } else {\n        std::cout << \"Test Case 2 FAILED: n=5.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 3: n = 3 (only Fizz)\n    std::vector<std::string> result3 = fizzBuzz(3);\n    std::vector<std::string> expected3 = {\"1\", \"2\", \"Fizz\"};\n    if (result3 == expected3) {\n        std::cout << \"Test Case 3 PASSED: n=3.\\n\";\n    } else {\n        std::cout << \"Test Case 3 FAILED: n=3.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 4: n = 1 (only number)\n    std::vector<std::string> result4 = fizzBuzz(1);\n    std::vector<std::string> expected4 = {\"1\"};\n    if (result4 == expected4) {\n        std::cout << \"Test Case 4 PASSED: n=1.\\n\";\n    } else {\n        std::cout << \"Test Case 4 FAILED: n=1.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 5: n = 0 (empty result)\n    std::vector<std::string> result5 = fizzBuzz(0);\n    std::vector<std::string> expected5 = {};\n    if (result5 == expected5) {\n        std::cout << \"Test Case 5 PASSED: n=0.\\n\";\n    } else {\n        std::cout << \"Test Case 5 FAILED: n=0.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 6: A number that is only divisible by 15 (after fix)\n    // This test will only pass if the bug is fixed (checking %15 first).\n    // For this test, we expect the *fixed* behavior.\n    std::vector<std::string> result6 = fizzBuzz(30);\n    std::vector<std::string> expected6_fixed;\n    for (int i = 1; i <= 30; ++i) {\n        if (i % 15 == 0) expected6_fixed.push_back(\"FizzBuzz\");\n        else if (i % 3 == 0) expected6_fixed.push_back(\"Fizz\");\n        else if (i % 5 == 0) expected6_fixed.push_back(\"Buzz\");\n        else expected6_fixed.push_back(std::to_string(i));\n    }\n\n    if (result6 == expected6_fixed) {\n        std::cout << \"Test Case 6 PASSED (assumes fix): n=30. Correctly handles FizzBuzz.\\n\";\n    } else {\n        std::cout << \"Test Case 6 FAILED (Bug present or unexpected output): n=30.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the fizzBuzz implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "28", "test": "#include <iostream>\n#include <string>\n#include <vector>\n#include <cassert>\n\n// The function to be tested (with the known bug)\nbool isPalindrome(int x) {\n    if (x < 0) return false;\n    int reversed = 0, original = x;\n    while (x != 0) {\n        // Handle potential overflow for reversed integer\n        // This is a common concern in palindrome number problems,\n        // though not the explicit bug identified here.\n        // If reversed exceeds INT_MAX/10, it will overflow.\n        // For this specific problem, let's assume inputs don't cause overflow\n        // or that it's implicitly handled by the test environment.\n        reversed = reversed * 10 + x % 10;\n        x /= 10;\n    }\n    return reversed == x; // Bug: Should be 'reversed == original'\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Palindrome number (expected to fail due to bug if x != 0)\n    // Correct: true\n    // Buggy: x becomes 0. reversed is 121. 121 == 0 is false. Returns false.\n    if (isPalindrome(121) != false) { // Asserting for the buggy behavior\n        std::cout << \"Test Case 1 FAILED (Buggy): 121. Expected false, Got \" << std::boolalpha << isPalindrome(121) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 PASSED (as expected with bug): 121.\\n\";\n    }\n\n    // Test Case 2: Non-palindrome number (expected to fail due to bug if x != 0)\n    // Correct: false\n    // Buggy: x becomes 0. reversed is 123. 123 == 0 is false. Returns false.\n    if (isPalindrome(123) != false) { // Asserting for the buggy behavior\n        std::cout << \"Test Case 2 FAILED (Buggy): 123. Expected false, Got \" << std::boolalpha << isPalindrome(123) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): 123.\\n\";\n    }\n\n    // Test Case 3: Negative number\n    // Correct: false\n    // Buggy: returns false (correctly, due to initial check)\n    if (isPalindrome(-121) != false) {\n        std::cout << \"Test Case 3 FAILED: -121. Expected false, Got \" << std::boolalpha << isPalindrome(-121) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 3 PASSED: -121.\\n\";\n    }\n\n    // Test Case 4: Zero\n    // Correct: true\n    // Buggy: x remains 0 (first if). reversed is 0. 0 == 0 is true. Returns true. (Correct by chance)\n    if (isPalindrome(0) != true) {\n        std::cout << \"Test Case 4 FAILED: 0. Expected true, Got \" << std::boolalpha << isPalindrome(0) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 4 PASSED: 0.\\n\";\n    }\n\n    // Test Case 5: Single digit number (positive)\n    // Correct: true\n    // Buggy: x becomes 0. reversed is single digit. single digit == 0 is false. Returns false.\n    if (isPalindrome(7) != false) { // Asserting for the buggy behavior\n        std::cout << \"Test Case 5 FAILED (Buggy): 7. Expected false, Got \" << std::boolalpha << isPalindrome(7) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 5 PASSED (as expected with bug): 7.\\n\";\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., `return reversed == original;`) ---\n\n    // Test Case 6: Palindrome number (after fix)\n    // Correct: true\n    if (isPalindrome(121) != true) {\n        std::cout << \"Test Case 6 FAILED (After Fix): 121. Expected true, Got \" << std::boolalpha << isPalindrome(121) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 6 PASSED (After Fix): 121.\\n\";\n    }\n\n    // Test Case 7: Non-palindrome number (after fix)\n    // Correct: false\n    if (isPalindrome(123) != false) {\n        std::cout << \"Test Case 7 FAILED (After Fix): 123. Expected false, Got \" << std::boolalpha << isPalindrome(123) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 7 PASSED (After Fix): 123.\\n\";\n    }\n\n    // Test Case 8: Single digit number (after fix)\n    // Correct: true\n    if (isPalindrome(7) != true) {\n        std::cout << \"Test Case 8 FAILED (After Fix): 7. Expected true, Got \" << std::boolalpha << isPalindrome(7) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 8 PASSED (After Fix): 7.\\n\";\n    }\n\n    // Test Case 9: Large palindrome\n    if (isPalindrome(123454321) != true) {\n        std::cout << \"Test Case 9 FAILED (After Fix): 123454321. Expected true, Got \" << std::boolalpha << isPalindrome(123454321) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 9 PASSED (After Fix): 123454321.\\n\";\n    }\n\n    // Test Case 10: Large non-palindrome\n    if (isPalindrome(123456789) != false) {\n        std::cout << \"Test Case 10 FAILED (After Fix): 123456789. Expected false, Got \" << std::boolalpha << isPalindrome(123456789) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 10 PASSED (After Fix): 123456789.\\n\";\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the isPalindrome implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "29", "test": "#include <iostream>\n#include <stack>\n#include <string>\n#include <cassert>\n\n// The function to be tested (with the known bug)\nbool isValid(std::string s) {\n    std::stack<char> st;\n    for (char c : s) {\n        if (c == '(' || c == '[' || c == '{') {\n            st.push(c);\n        } else {\n            if (st.empty()) return false; // Edge case: closing bracket with empty stack\n            char top = st.top(); st.pop();\n            if (c == ')' && top != '[') return false; // Bug: should check for '('\n            if (c == ']' && top != '[') return false; // This is correct\n            if (c == '}' && top != '{') return false; // This is correct\n        }\n    }\n    return st.empty(); // Check if all opening brackets have been closed\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Example from main (valid, should fail with bug)\n    // Correct: true\n    // Buggy: ')' expects '[', gets '('. Returns false.\n    if (isValid(\"({[]})\") != false) { // Expect false due to bug\n        std::cout << \"Test Case 1 FAILED (Buggy): '({[]})'. Expected false, Got \" << std::boolalpha << isValid(\"({[]})\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 PASSED (as expected with bug): '({[]})'.\\n\";\n    }\n\n    // Test Case 2: Simple valid parentheses (should fail with bug)\n    // Correct: true\n    // Buggy: ')' expects '[', gets '('. Returns false.\n    if (isValid(\"()\") != false) { // Expect false due to bug\n        std::cout << \"Test Case 2 FAILED (Buggy): '()'. Expected false, Got \" << std::boolalpha << isValid(\"()\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): '()'.\\n\";\n    }\n\n    // Test Case 3: Simple invalid case (unmatched ']', should pass with bug)\n    // Correct: false\n    // Buggy: ')' not checked. ']' expects '[', gets '('. Returns false.\n    if (isValid(\"(]\") != false) { // This will correctly return false, as top will be '(' and it expects '[' for ']' (correct check).\n        std::cout << \"Test Case 3 FAILED (Buggy): '(]'. Expected false, Got \" << std::boolalpha << isValid(\"(]\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 3 PASSED: '(]'.\\n\";\n    }\n\n    // Test Case 4: Invalid sequence (closing without opening, should pass with bug)\n    // Correct: false\n    // Buggy: stack empty, returns false. (Correctly handles this invalid case)\n    if (isValid(\"]\") != false) {\n        std::cout << \"Test Case 4 FAILED: ']'. Expected false, Got \" << std::boolalpha << isValid(\"]\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 4 PASSED: ']'.\\n\";\n    }\n\n    // Test Case 5: Empty string\n    // Correct: true\n    // Buggy: returns true (correctly)\n    if (isValid(\"\") != true) {\n        std::cout << \"Test Case 5 FAILED: ''. Expected true, Got \" << std::boolalpha << isValid(\"\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 5 PASSED: ''.\\n\";\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., `if (c == ')' && top != '(')`) ---\n\n    // Test Case 6: Example from main (after fix)\n    // Correct: true\n    if (isValid(\"({[]})\") != true) {\n        std::cout << \"Test Case 6 FAILED (After Fix): '({[]})'. Expected true, Got \" << std::boolalpha << isValid(\"({[]})\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 6 PASSED (After Fix): '({[]})'.\\n\";\n    }\n\n    // Test Case 7: Simple valid parentheses (after fix)\n    // Correct: true\n    if (isValid(\"()\") != true) {\n        std::cout << \"Test Case 7 FAILED (After Fix): '()'. Expected true, Got \" << std::boolalpha << isValid(\"()\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 7 PASSED (After Fix): '()'.\\n\";\n    }\n\n    // Test Case 8: Valid nested brackets\n    if (isValid(\"([]){\\n}{}\") != true) {\n        std::cout << \"Test Case 8 FAILED (After Fix): '([]){\\n}{}'. Expected true, Got \" << std::boolalpha << isValid(\"([]){\\n}{}\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 8 PASSED (After Fix): '([]){\\n}{}'.\\n\";\n    }\n\n    // Test Case 9: Invalid unmatched opening (stack not empty at end)\n    if (isValid(\"(\") != false) {\n        std::cout << \"Test Case 9 FAILED (After Fix): '('. Expected false, Got \" << std::boolalpha << isValid(\"(\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 9 PASSED (After Fix): '('.\\n\";\n    }\n\n    // Test Case 10: Invalid closing (mismatch)\n    if (isValid(\"({)}\") != false) {\n        std::cout << \"Test Case 10 FAILED (After Fix): '({)}'. Expected false, Got \" << std::boolalpha << isValid(\"({)}\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 10 PASSED (After Fix): '({)}'.\\n\";\n    }\n\n    // Test Case 11: Invalid closing (wrong order)\n    if (isValid(\"([)]\") != false) {\n        std::cout << \"Test Case 11 FAILED (After Fix): '([)]'. Expected false, Got \" << std::boolalpha << isValid(\"([)]\") << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 11 PASSED (After Fix): '([)]'.\\n\";\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the isValid implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "30", "test": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::max\n#include <limits>    // For std::numeric_limits\n#include <cassert>\n\n// The function to be tested (with the known bug)\nint maxSubArray(std::vector<int>& nums) {\n    int maxSum = 0; // Bug: Should be initialized to nums[0] or smallest possible int value\n    // If all numbers are negative, maxSum will remain 0, which is incorrect.\n    // e.g., for {-2, -1}, correct answer is -1, but this code returns 0.\n\n    int currentSum = 0;\n    for (int n : nums) {\n        currentSum = std::max(n, currentSum + n);\n        maxSum = std::max(maxSum, currentSum);\n    }\n    return maxSum;\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: All negative numbers (exposes bug)\n    // Correct: -1\n    // Buggy: max(0, max(-2, -2+0)) = max(0, -2) = 0. currentSum = max(-1, 0 + -1) = -1. maxSum = max(0, -1) = 0.\n    if (maxSubArray(std::vector<int>{-2, -1}) != 0) { // Expect 0 due to bug\n        std::cout << \"Test Case 1 FAILED (Buggy): {-2, -1}. Expected 0, Got \" << maxSubArray(std::vector<int>{-2, -1}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 PASSED (as expected with bug): {-2, -1}.\\n\";\n    }\n\n    // Test Case 2: All negative numbers, one large negative (exposes bug)\n    // Correct: -5\n    // Buggy: will return 0\n    if (maxSubArray(std::vector<int>{-10, -5, -8}) != 0) { // Expect 0 due to bug\n        std::cout << \"Test Case 2 FAILED (Buggy): {-10, -5, -8}. Expected 0, Got \" << maxSubArray(std::vector<int>{-10, -5, -8}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): {-10, -5, -8}.\\n\";\n    }\n\n    // Test Case 3: Mixed numbers (main example, should work correctly even with bug for positive sums)\n    // Correct: 6\n    // Buggy: returns 6 (correctly by chance as max sum is positive)\n    if (maxSubArray(std::vector<int>{-2, 1, -3, 4, -1, 2, 1, -5, 4}) != 6) {\n        std::cout << \"Test Case 3 FAILED: {-2,1,-3,4,-1,2,1,-5,4}. Expected 6, Got \" << maxSubArray(std::vector<int>{-2, 1, -3, 4, -1, 2, 1, -5, 4}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 3 PASSED: {-2,1,-3,4,-1,2,1,-5,4}.\\n\";\n    }\n\n    // Test Case 4: All positive numbers\n    // Correct: 10\n    // Buggy: returns 10 (correctly)\n    if (maxSubArray(std::vector<int>{1, 2, 3, 4}) != 10) {\n        std::cout << \"Test Case 4 FAILED: {1,2,3,4}. Expected 10, Got \" << maxSubArray(std::vector<int>{1, 2, 3, 4}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 4 PASSED: {1,2,3,4}.\\n\";\n    }\n\n    // Test Case 5: Single positive number\n    // Correct: 5\n    // Buggy: returns 5 (correctly)\n    if (maxSubArray(std::vector<int>{5}) != 5) {\n        std::cout << \"Test Case 5 FAILED: {5}. Expected 5, Got \" << maxSubArray(std::vector<int>{5}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 5 PASSED: {5}.\\n\";\n    }\n\n    // Test Case 6: Single negative number (exposes bug)\n    // Correct: -7\n    // Buggy: returns 0\n    if (maxSubArray(std::vector<int>{-7}) != 0) { // Expect 0 due to bug\n        std::cout << \"Test Case 6 FAILED (Buggy): {-7}. Expected 0, Got \" << maxSubArray(std::vector<int>{-7}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 6 PASSED (as expected with bug): {-7}.\\n\";\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., `maxSum` initialized to `nums[0]` or `numeric_limits<int>::min()`) ---\n\n    // Test Case 7: All negative numbers (after fix)\n    // Correct: -1\n    if (maxSubArray(std::vector<int>{-2, -1}) != -1) {\n        std::cout << \"Test Case 7 FAILED (After Fix): {-2, -1}. Expected -1, Got \" << maxSubArray(std::vector<int>{-2, -1}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 7 PASSED (After Fix): {-2, -1}.\\n\";\n    }\n\n    // Test Case 8: All negative numbers, one large negative (after fix)\n    // Correct: -5\n    if (maxSubArray(std::vector<int>{-10, -5, -8}) != -5) {\n        std::cout << \"Test Case 8 FAILED (After Fix): {-10, -5, -8}. Expected -5, Got \" << maxSubArray(std::vector<int>{-10, -5, -8}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 8 PASSED (After Fix): {-10, -5, -8}.\\n\";\n    }\n\n    // Test Case 9: Single negative number (after fix)\n    // Correct: -7\n    if (maxSubArray(std::vector<int>{-7}) != -7) {\n        std::cout << \"Test Case 9 FAILED (After Fix): {-7}. Expected -7, Got \" << maxSubArray(std::vector<int>{-7}) << \"\\n\";\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 9 PASSED (After Fix): {-7}.\\n\";\n    }\n\n    // Test Case 10: Empty array - The current implementation will crash\n    // It's good practice to handle empty arrays. A robust solution would add:\n    // `if (nums.empty()) return 0;` or throw an exception.\n    // Since the bug is about initialization, and empty array will crash on `nums[0]` if fixed that way,\n    // we need to assert that it crashes if no empty check.\n    // If you fix it by initializing to `numeric_limits<int>::min()` instead of `nums[0]`, then empty array would return `numeric_limits<int>::min()`.\n\n    // Assuming a fix that starts with `maxSum = nums[0];` and `nums` is guaranteed non-empty by problem context.\n    // Or if handling empty explicitly:\n    /*\n    std::vector<int> nums_empty = {};\n    try {\n        maxSubArray(nums_empty);\n        std::cout << \"Test Case 10 FAILED (Empty array did not throw as expected with nums[0] init): {}.\\n\";\n        all_tests_passed = false;\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Test Case 10 PASSED (Empty array threw out_of_range as expected): {}.\\n\";\n    }\n    */\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the maxSubArray implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "31", "test": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::swap\n#include <cassert>\n\n// The function to be tested (with the known bug)\nvoid moveZeroes(std::vector<int>& nums) {\n    int lastNonZero = 0;\n    for (int i = 0; i <= nums.size(); ++i) { // Bug: should be i < nums.size()\n        if (nums[i] != 0) { // This line will cause out-of-bounds access\n            std::swap(nums[lastNonZero++], nums[i]);\n        }\n    }\n}\n\n// Helper to print vector for debugging\nvoid printVector(const std::vector<int>& vec, const std::string& name) {\n    std::cout << name << \": [\";\n    for (size_t i = 0; i < vec.size(); ++i) {\n        std::cout << vec[i];\n        if (i < vec.size() - 1) {\n            std::cout << \", \";\n        }\n    }\n    std::cout << \"]\\n\";\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Example from main (will crash due to bug)\n    std::vector<int> nums1 = {0, 1, 0, 3, 12};\n    bool crashed_1 = false;\n    try {\n        moveZeroes(nums1);\n    } catch (const std::out_of_range& e) { // For std::vector out_of_range\n        std::cout << \"Test Case 1 PASSED (as expected with bug): {0,1,0,3,12} caused out_of_range.\\n\";\n        crashed_1 = true;\n    } catch (...) { // Catch any other potential crash (e.g., segmentation fault)\n        std::cout << \"Test Case 1 PASSED (as expected with bug): {0,1,0,3,12} caused a crash.\\n\";\n        crashed_1 = true;\n    }\n    if (!crashed_1) {\n        std::cout << \"Test Case 1 FAILED (Bug was not detected): {0,1,0,3,12}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 2: Array with no zeroes (will crash due to bug)\n    std::vector<int> nums2 = {1, 2, 3};\n    bool crashed_2 = false;\n    try {\n        moveZeroes(nums2);\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): {1,2,3} caused out_of_range.\\n\";\n        crashed_2 = true;\n    } catch (...) {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): {1,2,3} caused a crash.\\n\";\n        crashed_2 = true;\n    }\n    if (!crashed_2) {\n        std::cout << \"Test Case 2 FAILED (Bug was not detected): {1,2,3}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 3: Array with all zeroes (will crash due to bug)\n    std::vector<int> nums3 = {0, 0, 0};\n    bool crashed_3 = false;\n    try {\n        moveZeroes(nums3);\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Test Case 3 PASSED (as expected with bug): {0,0,0} caused out_of_range.\\n\";\n        crashed_3 = true;\n    } catch (...) {\n        std::cout << \"Test Case 3 PASSED (as expected with bug): {0,0,0} caused a crash.\\n\";\n        crashed_3 = true;\n    }\n    if (!crashed_3) {\n        std::cout << \"Test Case 3 FAILED (Bug was not detected): {0,0,0}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 4: Empty array (will crash due to bug, nums.size() will be 0, loop will run for i=0, accessing nums[0])\n    std::vector<int> nums4 = {};\n    bool crashed_4 = false;\n    try {\n        moveZeroes(nums4);\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Test Case 4 PASSED (as expected with bug): {} caused out_of_range.\\n\";\n        crashed_4 = true;\n    } catch (...) {\n        std::cout << \"Test Case 4 PASSED (as expected with bug): {} caused a crash.\\n\";\n        crashed_4 = true;\n    }\n    if (!crashed_4) {\n        std::cout << \"Test Case 4 FAILED (Bug was not detected): {}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., loop condition is `i < nums.size()`) ---\n\n    // Test Case 5: Example from main (after fix)\n    std::vector<int> nums5 = {0, 1, 0, 3, 12};\n    std::vector<int> expected5 = {1, 3, 12, 0, 0};\n    moveZeroes(nums5);\n    if (nums5 == expected5) {\n        std::cout << \"Test Case 5 PASSED (After Fix): {0,1,0,3,12} -> {1,3,12,0,0}.\\n\";\n    } else {\n        std::cout << \"Test Case 5 FAILED (After Fix): {0,1,0,3,12}. Got \"; printVector(nums5, \"\"); std::cout << \" Expected \"; printVector(expected5, \"\"); std::cout << \"\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 6: No zeroes\n    std::vector<int> nums6 = {1, 2, 3};\n    std::vector<int> expected6 = {1, 2, 3};\n    moveZeroes(nums6);\n    if (nums6 == expected6) {\n        std::cout << \"Test Case 6 PASSED (After Fix): {1,2,3} -> {1,2,3}.\\n\";\n    } else {\n        std::cout << \"Test Case 6 FAILED (After Fix): {1,2,3}. Got \"; printVector(nums6, \"\"); std::cout << \" Expected \"; printVector(expected6, \"\"); std::cout << \"\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 7: All zeroes\n    std::vector<int> nums7 = {0, 0, 0};\n    std::vector<int> expected7 = {0, 0, 0};\n    moveZeroes(nums7);\n    if (nums7 == expected7) {\n        std::cout << \"Test Case 7 PASSED (After Fix): {0,0,0} -> {0,0,0}.\\n\";\n    } else {\n        std::cout << \"Test Case 7 FAILED (After Fix): {0,0,0}. Got \"; printVector(nums7, \"\"); std::cout << \" Expected \"; printVector(expected7, \"\"); std::cout << \"\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 8: Zeroes at the beginning\n    std::vector<int> nums8 = {0, 0, 1, 2, 0, 3};\n    std::vector<int> expected8 = {1, 2, 3, 0, 0, 0};\n    moveZeroes(nums8);\n    if (nums8 == expected8) {\n        std::cout << \"Test Case 8 PASSED (After Fix): {0,0,1,2,0,3} -> {1,2,3,0,0,0}.\\n\";\n    } else {\n        std::cout << \"Test Case 8 FAILED (After Fix): {0,0,1,2,0,3}. Got \"; printVector(nums8, \"\"); std::cout << \" Expected \"; printVector(expected8, \"\"); std::cout << \"\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 9: Zeroes at the end (should not change anything)\n    std::vector<int> nums9 = {1, 2, 3, 0, 0};\n    std::vector<int> expected9 = {1, 2, 3, 0, 0};\n    moveZeroes(nums9);\n    if (nums9 == expected9) {\n        std::cout << \"Test Case 9 PASSED (After Fix): {1,2,3,0,0} -> {1,2,3,0,0}.\\n\";\n    } else {\n        std::cout << \"Test Case 9 FAILED (After Fix): {1,2,3,0,0}. Got \"; printVector(nums9, \"\"); std::cout << \" Expected \"; printVector(expected9, \"\"); std::cout << \"\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 10: Empty array (after fix)\n    std::vector<int> nums10 = {};\n    std::vector<int> expected10 = {};\n    moveZeroes(nums10);\n    if (nums10 == expected10) {\n        std::cout << \"Test Case 10 PASSED (After Fix): {} -> {}.\\n\";\n    } else {\n        std::cout << \"Test Case 10 FAILED (After Fix): {}. Got \"; printVector(nums10, \"\"); std::cout << \" Expected \"; printVector(expected10, \"\"); std::cout << \"\\n\";\n        all_tests_passed = false;\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the moveZeroes implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "32", "test": "#include <iostream>\n#include <vector>\n#include <algorithm> // Not strictly needed for this problem, but useful for generic tests.\n#include <cassert>\n\n// The function to be tested (with the known bug)\nint removeDuplicates(std::vector<int>& nums) {\n    if (nums.empty()) return 0; // Handle empty array edge case\n\n    int i = 1; // 'i' is the slow-runner pointer, also represents the length of the unique array\n    for (int j = 1; j < nums.size(); ++j) { // 'j' is the fast-runner pointer\n        if (nums[j] != nums[j-1]) {\n            nums[i] = nums[j];\n            i++;\n        }\n    }\n    return i + 1; // Bug: should be just 'i'\n}\n\n// Helper to print vector for debugging\nvoid printVector(const std::vector<int>& vec, int len, const std::string& name) {\n    std::cout << name << \": [\";\n    for (int k = 0; k < len; ++k) {\n        std::cout << vec[k];\n        if (k < len - 1) {\n            std::cout << \", \";\n        }\n    }\n    std::cout << \"]\\n\";\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Example from main (exposes bug)\n    // Input: {1, 1, 2}\n    // Correct Length: 2 (Array: {1, 2})\n    // Buggy Output: i becomes 2. returns 2 + 1 = 3.\n    std::vector<int> nums1 = {1, 1, 2};\n    int result1 = removeDuplicates(nums1);\n    if (result1 != 3) { // Expect 3 due to bug\n        std::cout << \"Test Case 1 FAILED (Buggy): {1,1,2}. Expected length 3, Got \" << result1 << \". Array: \"; printVector(nums1, result1, \"\");\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 1 PASSED (as expected with bug): {1,1,2}. Length: \" << result1 << \". Array: \"; printVector(nums1, result1, \"\");\n    }\n\n    // Test Case 2: All duplicates (exposes bug)\n    // Input: {1, 1, 1, 1}\n    // Correct Length: 1 (Array: {1})\n    // Buggy Output: i becomes 1. returns 1 + 1 = 2.\n    std::vector<int> nums2 = {1, 1, 1, 1};\n    int result2 = removeDuplicates(nums2);\n    if (result2 != 2) { // Expect 2 due to bug\n        std::cout << \"Test Case 2 FAILED (Buggy): {1,1,1,1}. Expected length 2, Got \" << result2 << \". Array: \"; printVector(nums2, result2, \"\");\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): {1,1,1,1}. Length: \" << result2 << \". Array: \"; printVector(nums2, result2, \"\");\n    }\n\n    // Test Case 3: No duplicates\n    // Input: {1, 2, 3, 4}\n    // Correct Length: 4 (Array: {1, 2, 3, 4})\n    // Buggy Output: i becomes 4. returns 4 + 1 = 5.\n    std::vector<int> nums3 = {1, 2, 3, 4};\n    int result3 = removeDuplicates(nums3);\n    if (result3 != 5) { // Expect 5 due to bug\n        std::cout << \"Test Case 3 FAILED (Buggy): {1,2,3,4}. Expected length 5, Got \" << result3 << \". Array: \"; printVector(nums3, result3, \"\");\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 3 PASSED (as expected with bug): {1,2,3,4}. Length: \" << result3 << \". Array: \"; printVector(nums3, result3, \"\");\n    }\n\n    // Test Case 4: Empty array (correctly handled by initial if statement)\n    // Input: {}\n    // Correct Length: 0\n    // Buggy Output: 0 (correctly)\n    std::vector<int> nums4 = {};\n    int result4 = removeDuplicates(nums4);\n    if (result4 != 0) {\n        std::cout << \"Test Case 4 FAILED: {}. Expected length 0, Got \" << result4 << \". Array: \"; printVector(nums4, result4, \"\");\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 4 PASSED: {}. Length: \" << result4 << \". Array: \"; printVector(nums4, result4, \"\");\n    }\n\n    // Test Case 5: Single element array\n    // Input: {5}\n    // Correct Length: 1\n    // Buggy Output: i remains 1. returns 1 + 1 = 2.\n    std::vector<int> nums5 = {5};\n    int result5 = removeDuplicates(nums5);\n    if (result5 != 2) { // Expect 2 due to bug\n        std::cout << \"Test Case 5 FAILED (Buggy): {5}. Expected length 2, Got \" << result5 << \". Array: \"; printVector(nums5, result5, \"\");\n        all_tests_passed = false;\n    } else {\n        std::cout << \"Test Case 5 PASSED (as expected with bug): {5}. Length: \" << result5 << \". Array: \"; printVector(nums5, result5, \"\");\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., `return i;`) ---\n\n    // Test Case 6: Example from main (after fix)\n    std::vector<int> nums6 = {1, 1, 2};\n    int result6 = removeDuplicates(nums6);\n    std::vector<int> expected_arr6 = {1, 2}; // Check content up to expected length\n    if (result6 == 2 && std::vector<int>(nums6.begin(), nums6.begin() + result6) == expected_arr6) {\n        std::cout << \"Test Case 6 PASSED (After Fix): {1,1,2} -> {1,2}. Length: \" << result6 << \".\\n\";\n    } else {\n        std::cout << \"Test Case 6 FAILED (After Fix): {1,1,2}. Got length \" << result6 << \". Array: \"; printVector(nums6, result6, \"\"); std::cout << \" Expected length 2. Array: {1,2}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 7: All duplicates (after fix)\n    std::vector<int> nums7 = {1, 1, 1, 1};\n    int result7 = removeDuplicates(nums7);\n    std::vector<int> expected_arr7 = {1};\n    if (result7 == 1 && std::vector<int>(nums7.begin(), nums7.begin() + result7) == expected_arr7) {\n        std::cout << \"Test Case 7 PASSED (After Fix): {1,1,1,1} -> {1}. Length: \" << result7 << \".\\n\";\n    } else {\n        std::cout << \"Test Case 7 FAILED (After Fix): {1,1,1,1}. Got length \" << result7 << \". Array: \"; printVector(nums7, result7, \"\"); std::cout << \" Expected length 1. Array: {1}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 8: No duplicates (after fix)\n    std::vector<int> nums8 = {1, 2, 3, 4};\n    int result8 = removeDuplicates(nums8);\n    std::vector<int> expected_arr8 = {1, 2, 3, 4};\n    if (result8 == 4 && std::vector<int>(nums8.begin(), nums8.begin() + result8) == expected_arr8) {\n        std::cout << \"Test Case 8 PASSED (After Fix): {1,2,3,4} -> {1,2,3,4}. Length: \" << result8 << \".\\n\";\n    } else {\n        std::cout << \"Test Case 8 FAILED (After Fix): {1,2,3,4}. Got length \" << result8 << \". Array: \"; printVector(nums8, result8, \"\"); std::cout << \" Expected length 4. Array: {1,2,3,4}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 9: Single element array (after fix)\n    std::vector<int> nums9 = {5};\n    int result9 = removeDuplicates(nums9);\n    std::vector<int> expected_arr9 = {5};\n    if (result9 == 1 && std::vector<int>(nums9.begin(), nums9.begin() + result9) == expected_arr9) {\n        std::cout << \"Test Case 9 PASSED (After Fix): {5} -> {5}. Length: \" << result9 << \".\\n\";\n    } else {\n        std::cout << \"Test Case 9 FAILED (After Fix): {5}. Got length \" << result9 << \". Array: \"; printVector(nums9, result9, \"\"); std::cout << \" Expected length 1. Array: {5}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 10: Larger array with mixed duplicates\n    std::vector<int> nums10 = {0, 0, 1, 1, 1, 2, 2, 3, 3, 4};\n    int result10 = removeDuplicates(nums10);\n    std::vector<int> expected_arr10 = {0, 1, 2, 3, 4};\n    if (result10 == 5 && std::vector<int>(nums10.begin(), nums10.begin() + result10) == expected_arr10) {\n        std::cout << \"Test Case 10 PASSED (After Fix): Mixed duplicates. Length: \" << result10 << \".\\n\";\n    } else {\n        std::cout << \"Test Case 10 FAILED (After Fix): Mixed duplicates. Got length \" << result10 << \". Array: \"; printVector(nums10, result10, \"\"); std::cout << \" Expected length 5. Array: {0,1,2,3,4}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the removeDuplicates implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "33", "test": "#include <iostream>\n#include <vector>\n#include <algorithm> // For std::swap\n#include <string>\n#include <cassert>\n\n// The function to be tested (with the known bug)\nvoid reverseString(std::vector<char>& s) {\n    int i = 0, j = s.size(); // Bug: should be s.size() - 1\n    while (i < j) {\n        // This swap will attempt to access s[s.size()] which is out of bounds.\n        std::swap(s[i++], s[j--]);\n    }\n}\n\n// Helper to convert vector<char> to string for easier comparison\nstd::string vecToString(const std::vector<char>& vec) {\n    return std::string(vec.begin(), vec.end());\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Example from main (will crash due to bug)\n    std::vector<char> s1 = {'h', 'e', 'l', 'l', 'o'};\n    bool crashed_1 = false;\n    try {\n        reverseString(s1);\n    } catch (const std::out_of_range& e) { // For std::vector out_of_range\n        std::cout << \"Test Case 1 PASSED (as expected with bug): {'h','e','l','l','o'} caused out_of_range.\\n\";\n        crashed_1 = true;\n    } catch (...) { // Catch any other potential crash (e.g., segmentation fault)\n        std::cout << \"Test Case 1 PASSED (as expected with bug): {'h','e','l','l','o'} caused a crash.\\n\";\n        crashed_1 = true;\n    }\n    if (!crashed_1) {\n        std::cout << \"Test Case 1 FAILED (Bug was not detected): {'h','e','l','l','o'}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 2: Even length string (will crash due to bug)\n    std::vector<char> s2 = {'a', 'b', 'c', 'd'};\n    bool crashed_2 = false;\n    try {\n        reverseString(s2);\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): {'a','b','c','d'} caused out_of_range.\\n\";\n        crashed_2 = true;\n    } catch (...) {\n        std::cout << \"Test Case 2 PASSED (as expected with bug): {'a','b','c','d'} caused a crash.\\n\";\n        crashed_2 = true;\n    }\n    if (!crashed_2) {\n        std::cout << \"Test Case 2 FAILED (Bug was not detected): {'a','b','c','d'}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 3: Single character string (will crash due to bug, s.size()=1, j=1, access s[1])\n    std::vector<char> s3 = {'x'};\n    bool crashed_3 = false;\n    try {\n        reverseString(s3);\n    } catch (const std::out_of_range& e) {\n        std::cout << \"Test Case 3 PASSED (as expected with bug): {'x'} caused out_of_range.\\n\";\n        crashed_3 = true;\n    } catch (...) {\n        std::cout << \"Test Case 3 PASSED (as expected with bug): {'x'} caused a crash.\\n\";\n        crashed_3 = true;\n    }\n    if (!crashed_3) {\n        std::cout << \"Test Case 3 FAILED (Bug was not detected): {'x'}. Didn't crash.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 4: Empty string (will not crash because s.size() is 0, j=0, while loop i < j is false)\n    // Correct: empty string\n    // Buggy: empty string (correctly)\n    std::vector<char> s4 = {};\n    try {\n        reverseString(s4);\n        if (s4.empty()) {\n            std::cout << \"Test Case 4 PASSED: {} handled gracefully by bugged code.\\n\";\n        } else {\n            std::cout << \"Test Case 4 FAILED: {}. Expected empty, got \" << vecToString(s4) << \".\\n\";\n            all_tests_passed = false;\n        }\n    } catch (...) {\n        std::cout << \"Test Case 4 FAILED: {} unexpectedly crashed.\\n\";\n        all_tests_passed = false;\n    }\n\n    // --- Tests assuming the bug is fixed (i.e., `j = s.size() - 1`) ---\n\n    // Test Case 5: Example from main (after fix)\n    std::vector<char> s5 = {'h', 'e', 'l', 'l', 'o'};\n    std::string expected5 = \"olleh\";\n    reverseString(s5);\n    if (vecToString(s5) == expected5) {\n        std::cout << \"Test Case 5 PASSED (After Fix): 'hello' -> 'olleh'.\\n\";\n    } else {\n        std::cout << \"Test Case 5 FAILED (After Fix): 'hello'. Got '\" << vecToString(s5) << \"' Expected '\" << expected5 << \"'.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 6: Even length string (after fix)\n    std::vector<char> s6 = {'a', 'b', 'c', 'd'};\n    std::string expected6 = \"dcba\";\n    reverseString(s6);\n    if (vecToString(s6) == expected6) {\n        std::cout << \"Test Case 6 PASSED (After Fix): 'abcd' -> 'dcba'.\\n\";\n    } else {\n        std::cout << \"Test Case 6 FAILED (After Fix): 'abcd'. Got '\" << vecToString(s6) << \"' Expected '\" << expected6 << \"'.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 7: Single character string (after fix)\n    std::vector<char> s7 = {'x'};\n    std::string expected7 = \"x\";\n    reverseString(s7);\n    if (vecToString(s7) == expected7) {\n        std::cout << \"Test Case 7 PASSED (After Fix): 'x' -> 'x'.\\n\";\n    }\n    else {\n        std::cout << \"Test Case 7 FAILED (After Fix): 'x'. Got '\" << vecToString(s7) << \"' Expected '\" << expected7 << \"'.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 8: Empty string (after fix)\n    std::vector<char> s8 = {};\n    std::string expected8 = \"\";\n    reverseString(s8);\n    if (vecToString(s8) == expected8) {\n        std::cout << \"Test Case 8 PASSED (After Fix): '' -> ''.\\n\";\n    } else {\n        std::cout << \"Test Case 8 FAILED (After Fix): ''. Got '\" << vecToString(s8) << \"' Expected '\" << expected8 << \"'.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 9: Longer string\n    std::vector<char> s9 = {'t','e','s','t','i','n','g',' ','r','e','v','e','r','s','a','l'};\n    std::string expected9 = \"lasrever gnits et\";\n    reverseString(s9);\n    if (vecToString(s9) == expected9) {\n        std::cout << \"Test Case 9 PASSED (After Fix): Longer string.\\n\";\n    } else {\n        std::cout << \"Test Case 9 FAILED (After Fix): Longer string. Got '\" << vecToString(s9) << \"' Expected '\" << expected9 << \"'.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic (considering the bug where applicable).\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the reverseString implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}
{"issue": "34", "test": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm> // For std::sort and std::equal\n#include <cassert>\n\n// Function to be tested (with the known \"bug\" that might not be a bug for the specified case)\nstd::vector<int> twoSum(std::vector<int>& nums, int target) {\n    std::unordered_map<int, int> map;\n    for (int i = 0; i < nums.size(); ++i) {\n        int complement = target - nums[i];\n        if (map.count(complement)) {\n            return {map[complement], i};\n        }\n        map[nums[i]] = i;\n    }\n    return {}; // Returns empty vector if no solution is found\n}\n\n// Helper to sort and compare vectors of indices (order of indices might vary but content should match)\nbool compareIndexVectors(const std::vector<int>& a, const std::vector<int>& b) {\n    if (a.size() != b.size()) return false;\n    if (a.empty()) return true; // Both empty\n    std::vector<int> sorted_a = a;\n    std::vector<int> sorted_b = b;\n    std::sort(sorted_a.begin(), sorted_a.end());\n    std::sort(sorted_b.begin(), sorted_b.end());\n    return sorted_a == sorted_b;\n}\n\nint main() {\n    bool all_tests_passed = true;\n\n    // Test Case 1: Example from main (duplicates, target=6)\n    // Analysis: The code *does not* fail for [3,3], target 6. It correctly returns {0, 1}.\n    std::vector<int> nums1 = {3, 3};\n    int target1 = 6;\n    std::vector<int> result1 = twoSum(nums1, target1);\n    std::vector<int> expected1 = {0, 1};\n    if (compareIndexVectors(result1, expected1)) {\n        std::cout << \"Test Case 1 PASSED: {3,3}, target 6. Result: [\" << result1[0] << \", \" << result1[1] << \"] (Correct behavior, no bug detected here as per analysis).\\n\";\n    } else {\n        std::cout << \"Test Case 1 FAILED: {3,3}, target 6. Expected {0,1}, Got {\" << (result1.empty() ? \"\" : std::to_string(result1[0])) << (result1.size() > 1 ? \", \" + std::to_string(result1[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 2: Standard case, solution exists\n    std::vector<int> nums2 = {2, 7, 11, 15};\n    int target2 = 9;\n    std::vector<int> result2 = twoSum(nums2, target2);\n    std::vector<int> expected2 = {0, 1};\n    if (compareIndexVectors(result2, expected2)) {\n        std::cout << \"Test Case 2 PASSED: {2,7,11,15}, target 9. Result: [\" << result2[0] << \", \" << result2[1] << \"] (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 2 FAILED: {2,7,11,15}, target 9. Expected {0,1}, Got {\" << (result2.empty() ? \"\" : std::to_string(result2[0])) << (result2.size() > 1 ? \", \" + std::to_string(result2[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 3: No solution\n    std::vector<int> nums3 = {1, 2, 3};\n    int target3 = 7;\n    std::vector<int> result3 = twoSum(nums3, target3);\n    std::vector<int> expected3 = {};\n    if (result3.empty() && expected3.empty()) {\n        std::cout << \"Test Case 3 PASSED: {1,2,3}, target 7. Result: {} (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 3 FAILED: {1,2,3}, target 7. Expected {}, Got {\" << (result3.empty() ? \"\" : std::to_string(result3[0])) << (result3.size() > 1 ? \", \" + std::to_string(result3[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 4: Target at the beginning of array\n    std::vector<int> nums4 = {3, 2, 4};\n    int target4 = 6;\n    std::vector<int> result4 = twoSum(nums4, target4);\n    std::vector<int> expected4 = {1, 2}; // 2+4=6, indices 1 and 2\n    if (compareIndexVectors(result4, expected4)) {\n        std::cout << \"Test Case 4 PASSED: {3,2,4}, target 6. Result: [\" << result4[0] << \", \" << result4[1] << \"] (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 4 FAILED: {3,2,4}, target 6. Expected {1,2}, Got {\" << (result4.empty() ? \"\" : std::to_string(result4[0])) << (result4.size() > 1 ? \", \" + std::to_string(result4[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 5: Negative numbers\n    std::vector<int> nums5 = {-1, -2, -3, -4, -5};\n    int target5 = -8;\n    std::vector<int> result5 = twoSum(nums5, target5);\n    std::vector<int> expected5 = {2, 4}; // -3 + -5 = -8, indices 2 and 4\n    if (compareIndexVectors(result5, expected5)) {\n        std::cout << \"Test Case 5 PASSED: {-1,-2,-3,-4,-5}, target -8. Result: [\" << result5[0] << \", \" << result5[1] << \"] (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 5 FAILED: {-1,-2,-3,-4,-5}, target -8. Expected {2,4}, Got {\" << (result5.empty() ? \"\" : std::to_string(result5[0])) << (result5.size() > 1 ? \", \" + std::to_string(result5[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 6: Zeroes in array\n    std::vector<int> nums6 = {0, 4, 3, 0};\n    int target6 = 0;\n    std::vector<int> result6 = twoSum(nums6, target6);\n    std::vector<int> expected6 = {0, 3}; // 0 + 0 = 0, indices 0 and 3\n    if (compareIndexVectors(result6, expected6)) {\n        std::cout << \"Test Case 6 PASSED: {0,4,3,0}, target 0. Result: [\" << result6[0] << \", \" << result6[1] << \"] (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 6 FAILED: {0,4,3,0}, target 0. Expected {0,3}, Got {\" << (result6.empty() ? \"\" : std::to_string(result6[0])) << (result6.size() > 1 ? \", \" + std::to_string(result6[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 7: Single element (no solution possible)\n    std::vector<int> nums7 = {5};\n    int target7 = 10;\n    std::vector<int> result7 = twoSum(nums7, target7);\n    std::vector<int> expected7 = {};\n    if (result7.empty() && expected7.empty()) {\n        std::cout << \"Test Case 7 PASSED: {5}, target 10. Result: {} (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 7 FAILED: {5}, target 10. Expected {}, Got {\" << (result7.empty() ? \"\" : std::to_string(result7[0])) << (result7.size() > 1 ? \", \" + std::to_string(result7[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Test Case 8: Large numbers, target requires sum from far ends\n    std::vector<int> nums8 = {1000, 2000, 3000, 4000, 5000};\n    int target8 = 6000;\n    std::vector<int> result8 = twoSum(nums8, target8);\n    std::vector<int> expected8 = {0, 4}; // 1000 + 5000 = 6000, indices 0 and 4\n    if (compareIndexVectors(result8, expected8)) {\n        std::cout << \"Test Case 8 PASSED: {1000,2000,3000,4000,5000}, target 6000. Result: [\" << result8[0] << \", \" << result8[1] << \"] (Correct).\\n\";\n    } else {\n        std::cout << \"Test Case 8 FAILED: {1000,2000,3000,4000,5000}, target 6000. Expected {0,4}, Got {\" << (result8.empty() ? \"\" : std::to_string(result8[0])) << (result8.size() > 1 ? \", \" + std::to_string(result8[1]) : \"\") << \"}.\\n\";\n        all_tests_passed = false;\n    }\n\n    // Final summary\n    if (all_tests_passed) {\n        std::cout << \"\\nAll tests PASSED for the current logic.\\n\";\n    } else {\n        std::cout << \"\\nSome tests FAILED. Review the twoSum implementation or expected outputs.\\n\";\n    }\n\n    return all_tests_passed ? 0 : 1; // Return 0 for success, 1 for failure\n}\n"}